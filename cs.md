# 第 1 章 计算机系统漫游

## 1.2 程序被其他程序翻译成不同的格式    

```c
// hello.c
#include <stdio.h>

int main() {
  printf("hello world\n");
  return 0;
}
```    

hello 程序的生命周期是从一个高级 C 语言程序开始的，因为这种形式能够被人读懂。然后，为了
在系统上运行 hello.c 程序，每条 C 语句必须被其他程序转化为一系列的低级 **机器语言** 指令。
然后这些指令按照一种称为 **可执行目标程序** 的格式打好包，并以二进制磁盘文件的形式存放
起来。目标程序也称为 **可执行目标文件**。   

在 Unix 系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：   

`linux> gcc -o hello hello.c`    

这个翻译过程可分为四个阶段完成，执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）
一起构成了 **编译系统**：    

![compilation-system](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/compilation-system.png)   

+ _预处理阶段_。预处理器 cpp 根据以字符 # 开头的命令，修改原始的 C 程序。比如 hello.c
中的第 1 行的 `#include <stdio.h>` 命令告诉预处理器读取系统头文件 stdio.h 的内容，并把
它直接插入程序文本中。结果就得到了另一个 C 程序，通常是以 .i 作为文件扩展名。
+ _编译阶段_。编译器 ccl 将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言
程序。该程序包含函数 main 的定义，如下所示：   
```asm
1  main:
2    subq     $8, %rsp
3    movl     $.LCO, %edi
4    call     puts
5    movl     $0, %eax
6    addq     $8. %rsp
7    ret
```    
+ _汇编阶段_。接下来，汇编器 as 将 hello.s 翻译成机器语言指令，并把这些指令打包成一种
叫做 **可重定位目标程序**(relocatable object program)的格式，并将结果保存在目标文件
hello.o 中。hello.o 文件是一个二进制文件，它包含的 17 个字节是函数 main 的指令编码。
+ _链接阶段_。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中。而这个
文件必须以某种方式合并到我们的 hello.o 程序中。链接器 ld 就负责处理这种合并。结果就得到
hello 文件，它是一个可执行目标文件，可以被加载到内存中，由系统执行。   

看这个意思，可**程序一般是指一种文件的格式，而可\*\*文件就是最后的某种文件。   

## 1.4 处理器读并解释储存在内存中的指令

### 1.4.1 系统的硬件组成

![system-hardware](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/system-hardware.png)   

1. **总线**    

贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被
设计成传送定长的字节块，也就是 **字**(word)。字中的字节数（即字长）是一个基本的系统参数，
各个系统中都不尽相同，现在大多数机器字长要么是 4 个字节，要么是 8 个字节。    

2. **I/O 设备**    

每个 I/O 设备都通过一个 **控制器** 或 **适配器** 与 I/O 总线相连。控制器与适配器之间的
区别主要在于它们的封装方式。控制器是 I/O 设备本身或者系统的主板上的芯片组。而适配器则
是一块插在主板插槽上的卡。无论如何，它们的功能都是在 I/O 总线和 I/O 设备之间传递信息。    

3. **处理器**    

处理器的核心是一个大小为一个字的存储设备（或寄存器），称为 **程序计数器**(PC)。在任何
时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。     

从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数
器，使其指向下一条指令。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列
的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，
然后更新 PC，使其指向下一条指令。    

这样的简单操作并不多，它们围绕着主存、寄存器文件和 **算术/逻辑单元**(ALU) 进行。寄存器
文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU 计算
新的数据和地址值。下面是一些简单操作的例子，CPU 在指令的要求下可能会执行这些操作：   

+ **加载**：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。
+ **存储**：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。
+ **操作**：把两个寄存器的内容复制到 ALU，ALU 对这两个字做算术运算，并将结果存放到一个
寄存器中，以覆盖该寄存器中原来的内容。
+ **跳转**：从指令本身中抽取一个字，并将这个字复制到程序计数器中，以覆盖 PC 中原来的值。    

处理器看上去是他的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速
程序的执行。因此，我们将处理器的 **指令集架构** 和处理器的 **微体系结构** 区分开来：
指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。   

## 1.5 高速缓存至关重要

一个典型的寄存器文件只存储几百字节的信息。看这个意思，一个单个寄存器应该就是一个字长的
大小，而一个寄存器文件通常是多个寄存器的集合。    

位于处理器芯片的 **L1 高速缓存** 的容量可以达到数万字节，访问速度几乎和访问寄存器文件
一样快。一个容量为数十万到数百万字节的更大的 **L2 高速缓存** 通过一条特殊的总线连接到
处理器。进程访问 L2 高速缓存的时间要比访问 L1 高速缓存的时间长 5 倍。L1 和 L2 高速缓存
使用一种叫做静态随机访问存储器(SRAM)的硬件技术实现的。

## 1.9 重要主题

### 1.9.2 并发和并行

我们用的术语 **并发** 是一个通用的概念，指一个同时具有多个活动的系统；而术语 **并行**
指的是用并发来使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用。在此，我们
按照层次结构中由高到低的顺序重点强调三个层次。    

1. **线程级并发**     

超线程，有时称为 **同时多线程**，是一项允许一个 CPU 执行多个控制流的技术。它涉及 CPU 某些
硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份，比如执行浮点算术运算
的单元。常规的处理器需要大约 20 000 个时钟周期做不同线程间的切换，而超线程的处理器可以在
单个周期的基础上决定要执行哪一个资源。这使得 CPU 能够更好地利用它的处理资源。比如，假设
一个线程必须等到某些数据被装载到高速缓存中，那 CPU 就可以继续去执行另一个线程。     

那也就是说可能我们装载程序的时候，就把不同的线程内容装载到不同的硬件备份中，从这个角度来看，
执行单元应该都只有一份，但一些存储单元应该都是有两份，这样当线程切换时，我们压根不用从内存
中保存和调出线程的上下文，而是直接让执行单元执行另一个 PC 中保存的指令即可。   

2. **指令级并行**    

首先我们需要明确一点，时钟周期和指令并不是一一对应的，并不是说一个时钟周期执行一条指令，
另外一条指令和其要执行的操作也不是一一对应的，一条指令可能要完成多个操作。   

在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为 **指令级并行**。最近的处理器
可以保持某个时钟周期 2~4 条指令的执行速率。其实每条执行从开始到结束需要长得多的时间，大约
20 个或者更多周期，但是处理器使用了非常多的聪明技巧来同时处理多达 100 条指令。    

在流水线中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，
每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。    

如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为 **超标量** 处理器。大多数
现代处理器都支持超标量操作。   

3. **单指令、多数据并行**    

在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种
方式称为 **单指令、多数据**，即 SIMD 并行。    


# 第一部分 程序结构和执行

我们对计算机系统的探索是从学习计算机本身开始的，它由处理器和存储器子系统组成。在核心部分，
我们需要方法来表示基本数据类型，比如整数和实数运算的近似值。然后，我们考虑机器级指令如何
操作这样的数据，以及编译器又如何将 C 程序翻译成这样的指令。接下来，研究几种实现处理器的
方法，帮助我们更好地了解硬件资源如何被用来执行指令。    

# 第 2 章 信息的表示和处理

我们研究三种最重要的数字表示。*无符号* (unsigned)编码基于传统的二进制表示法，表示大于或者
等于零的数字。*补码* (two's-complement)编码是表示有符号整数的最常见的方式。*浮点数* (floating-point)
编码是表示实数的科学计数法的以 2 为基数的版本。   

计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以致不能表示时，某些计算
就会溢出。例如，在 int32 类型情况下，计算表达式 200\*300\*400*500 会得出结果 -884 901 888.    

另一方面，整数的计算机运算满足人们所熟知的真正整数运算的许多性质。例如，利用乘法的结合律
和交换律，计算下面任何一个 C 表达式，都会得出一个结果 -884 901 888:   

+ (500 * 400) * (300 * 200)
+ ((500 * 400) * 300) * 200
+ ((200 * 500) * 300) * 400
+ 400 * (200 * (300 * 500))    

计算机可能没有产生期望的结果，但是至少它是一致的！    

浮点运算有完全不同的数学属性。虽然溢出会产生特殊的值 +∞，但是一组正数的乘积总是正的。由于
表示的精度有限，浮点运算是不可结合的。例如，在大多数机器上，C 表达式 (3.14 + 1e20) - 1e20
求得的值会是 0.0，而 3.14 + (1e20 - 1e20) 求得的值会是 3.14。   

整数运算和浮点数运算会有不同的数学属性是因为他们处理数字表示有限性的方式不同——整数的表示
虽然只能编码一个相对较小的数值范围，但是这种表示时精确的；而浮点数虽然可以编码一个较大的
数值范围，但是这种表示只是近似的。   

## 2.1 信息存储

### 2.1.2 字数据大小

每台计算机都有一个 **字长**，指明指针数据的标称大小。因为虚拟地址是以这样的一个字来编码的，
所以决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为 w 位的机器
而言，虚拟地址的范围是 0 ~ 2<sup>w</sup>-1，程序最多访问 2<sup>w</sup> 个字节。    

我们将程序称为 “32位程序” 或 “64位程序” 时，区别在于该程序是如何编译的，而不是其运行的
机器类型。   

### 2.1.3 寻址和字节顺序

对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何
排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用
字节中最小的地址。     

排列表示一个对象的字节有两个通用的规则。考虑一个 w 位的整数，其位表示为 [x<sub>w-1</sub>,
w<sub>w-2</sub>, ..., x<sub>1</sub>, x<sub>0</sub>]。假设 w 是 8 的倍数，这些位就
能被分组成字节，某些机器在内存中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些
机器则按照从最高有效字节到最低有效字节的顺序存储。前一种规则称为 **小端法**，后一种规则
称为 **大端法**。    

假设变量 x 的类型为 int32, 位于地址 0x100 处，它的十六进制值为 0x01234567。地址范围
0x100~0x103 的字节顺序依赖于机器的类型：    

![big-endian-and-little-endian](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/big-little-endian.png)   

大多数 Intel 兼容机都只用小端模式。   

对于大多数应用程序员来说，其机器所使用的字节顺序是完全不可见的。无论为哪种类型的机器所
编译的程序都会得到同样的结果。不过有时候，字节顺序会成为问题。首先，是在不同类型的机器
之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者
反过来。     

### 2.1.4 表示字符串

C 语言中字符串被编码为一个以 null(acsii 码为0)字符结尾的字符数组。    

### 2.1.6 布尔代数简介

**布尔代数和布尔环**    

对于任意整数 w &gt; 0，长度为 w 的位向量上的布尔运算 |, & 和 ~ 形成了一个布尔代数。最
简单的情况是 w = 1 时，只有 2 个元素；但是对于更普遍的情况，有 2<sup>w</sup> 个长度为
w 的位向量。布尔代数和整数算术运算有很多相似之处。例如，乘法对加法的分配律 a * (b+c) =
(a * b) + (a * c)，而布尔运算 & 对 | 的分配律，a & (b | c) = (a & b) | (a & c)。
此外，布尔运算 | 对 & 也有分配律， a | (b & c) = (a | b) & (a | c)，但是对于整数我们
不能说 a + (b * c) = (a + b) * (a + c)。    

也就是 数据集合(2<sup>w</sup>个数) + 运算(|, &, ~) = 布尔代数。    

当考虑长度为 w 的位向量上的 ^, & 和 ~ 运算时，会得到一种不同的数学形式，我们称为布尔环。    

### 2.1.9 C 语言中的移位运算

右移运算 x &gt;&gt; k，一般而言，机器支持两种形式的右移：**逻辑右移** 和 **算术右移**。
逻辑右移在左端补 k 个 0，算术右移在左端补 k 个最高有效位的值。     

几乎所有的编译器/机器组合都对有符号数使用算术右移，另一方面，对于无符号数，右移必须是逻辑的。    

## 2.2 整数表示

这里需要格外注意一点，图里 x 声明为向量的，其实意指一个二进制的 0,1 串，而一个数字 x 其实
代表一个普通的数字。   

### 2.2.2 无符号数的编码

假设有一个整数数据类型有 w 位，我们可以将位向量写成 x, 表示整个向量，或者写成[x<sub>w-1</sub>,
x<sub>w-2</sub>, ..., x<sub>0</sub>]，表示向量中的每一位。把 x 看做一个二进制表示的数，
就获得了 x 的无符号表示。B2U(Binary to Unsigned 的缩写，长度为 w)：   

![Binary-to-Unsigned](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/btu.png)   

函数的输入是一个二进制向量，而输出是一个十进制的数字。    

函数 B2U 将一个长度为 w 的0,1 串映射到非负整数。因此一个采用 B2U 函数编码的无符号数的
取值范围是 0~2<sup>w</sup> - 1.一共包含 2<sup>w</sup> 个数。     

好像是这个意思，我们给定一个二进制表示的串，这个串肯定是可以代表一个数字的，但具体的是怎样的一个
数，其实取决于我们认为的编码方式，如果我们认为这个二进制串按照无符号数解释，那这个数字就可以通过
B2U 函数算出来，如果是补码的编码方式，那可以通过下面的 B2T 函数算出来。但是其实我们使用
的时候都是应该用的反向操作 U2B，即给一个数字，其为无符号编码，在内存中保存了其二进制格式的
数据。   

原理：无符号数编码的唯一性。函数 B2U 是一个双射。    

### 2.2.3 补码编码

对于很多应用，我们还希望表示负数值。最常见的有符号数的计算机表示方式就是 **补码**(two's-complenment)
形式。在这个定义中，将字的最高有效位解释为负权。我们用函数 B2T<sub>w</sub>(Binary to Two's-complement，
长度为w)来表示：    

![Binary-to-Two's-complement](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/btt.png)  

让我们来考虑一下 w 位补码所能表示的值的范围。它能表示的最小值是位向量[100....0]，其整数
值为 TMin<sub>w</sub> = -2<sub>w-1</sub>。而最大值是位向量 [01...1]，其整数值为
TMax<sub>w</sub> = 2<sup>w-1</sup> - 1.     

同无符号表示一样，在可表示的取值范围内的每个数字都有唯一一个的 w 位的补码编码。这就导出
了与无符号数相似的补码数原理：   

原理：补码编码的唯一性。函数 B2T 是一个双射。    

![important-numbers](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/important-numbers.png)  

关于这些数字，有几点值得注意。第一，补码的范围是不对称的：|TMin| = |TMax| + 1，也就是说，
TMin 没有与之对应的正数。正如我们将看到的，这导致了补码运算的某些特殊的属性，并且容易造成
程序中细微的错误。之所以有这样的不对称性，是因为一半的位模式（符号位设置为 1 的数）表示
负数，而另一半（符号位设置为0的数）表示非负数。因为 0 是非负数，也就意味着能表示的正数
比负数少一个。     

![ones-sign](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/ones-sign.png)   

**重点：**请注意补码（Two's complement）和反码（Ones' complement）中撇号的位置是不同的。
术语补码来源于这样一个情况，对于非负数 x，我们用 2<sup>w</sup> - x（这里只有一个 2）来
计算 -x 的 w 位表示。术语反码来源于这样一个属性，我们用 [111...1] - x（这里有很多个 1）
来计算 -x 的反码表示。   

### 2.2.4 有符号数和无符号数之间的转换

C 语言允许在各种不同的数字数据类型之间做强制类型转换。将有符号数强制转换成无符号数，或者
反过来，会得到什么结果呢？从数学的角度来说，可以想象到几种不同的规则。很明显，对于在两种形式
中都能表示的值，我们是想要保持不变的。另一方面，将负数转换成无符号数可能会得到 0。如果转换
的无符号数太大以至于超出了补码能够表示的范围，可能会得到 TMax。    

然而，对于大多数 C 语言的实现来说，对这个问题的回答都是从 **位级角度** 来看的，而不是数的
角度。   

考虑如下代码：   

```c
short int v = -12345;
unsigned short uv = (unsigned short) v;
printf("v = %d, uv = %u\n", v, uv);
```   

在一台使用补码的机器上，上述代码会产生如下输出：    

v = -12345, uv = 53191    

我们看到，强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。-12345 的 16 位补码
表示与 53191 的 16 位无符号表示是完全一样的。    

类似地，考虑如下的代码：    

```c
unsigned u = 4294967295u;   // UMax
int tu = (int) u;
printf("u = %u, tu = %d\n", u, tu);
```    

在一台使用补码的机器上，上述代码会产生如下输出：   

u = 4294967295, tu = -1    

对于大多数 C 语言的实现，处理 **同样字长** 的有符号数和无符号数之间相互转换的一般规则是：数值
可能会改变，但是位模式不变。让我们用更数学化的形式来描述这个规则。我们定义函数 U2B 和 T2B，
它们将数值映射为无符号数和补码形式的位表示。也就是说，给定 0 &lt;= x &lt;= UMax 范围内的
一个整数 x，函数 U2B(x) 会给出 x 的唯一的 w 位无符号表示。注意 U2B 和 T2B 都是双射。     

现在，将函数 T2U 定义为 T2U(x) = B2U(T2B(x))。这个函数的输入是一个 TMin~TMax 的数，结果
得到一个 0~UMax 的值。   

**补码转换为无符号数：**    

![t2u](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/t2u.png)   

注意上面的推导少了很重要的一步就是 **x** = T2B(x)，左边加粗的 x 代表向量 **x**，然后将式中的
向量 **x** 进行替换，就可以推导出来了。   

**无符号数转换为补码：**    

![u2t](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/u2t.png)   

### 2.2.6 扩展一个数字的位表示

一个常见的运算是在不同字长的整数之间转换，同时又保持数值不变。当然，当目标数据类型太小以
至于不能表示想要的值时，这根本就是不可能的。然而，从一个较小的数据类型转换到一个较大的类型，
应该总是可能的。    

要将一个无符号数转换为一个更大的数据类型，我们只要简单地在表示的开头添加 0，这种运算被称为
**零扩展**。    

要将一个补码数字转换为一个更大的数据类型，可以执行一个 **符号扩展**，在表示中添加最高有效位的
值。     

注意这里补码进行了符号扩展后的代表的数字是不变的，不要想当然负数加了好多 1 数字就变了，下面是
证明过程。   

![prove-sign-extension](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/prove-sign-extension.png)   

值得一提的是，如果我们同时进行了数据大小和有符号无符号之间的转换。是可能影响程序的行为的。
例如 short sx; (unsigned) sx 等价于 (unsigned) (int) sx。    

### 2.2.7 截断数字

假设我们不用额外的位来扩展一个数值，而是减少表示一个数字的位数。例如下面代码中这种情况：   

```c
int x = 53191;    // 0000cfc7
short sx = (short) x;   // -12345 cfc7
int y = sx;     // -12345 ffffcfc7
```   

当将一个 w 位的数截断成一个 k 位数字时，我们会丢弃高 w-k 位。截断一个数字可能会改变他的
值——溢出的一种形式。   

**截断无符号数：**    

![truncated-unsigned](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/truncated-unsigned.png)   

**截断补码数值：**    

![truncated-two's](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/truncated-two's.png)   

## 2.3 整数运算

### 2.3.1 无符号加法

让我们为参数 x 和 y （无符号数）定义运算 +<sup>u</sup><sub>w</sub>，其中 0 &lt;= x, y &lt; 2<sup>w</sup>，
该操作是把整数和 x + y 截断为 w 位得到的结果，再把这个结果看做是一个无符号数。这可以被
视为一种形式的模运算，对 x+y 的位级表示，简单丢弃任何权重大于 2<sup>w-1<sup> 的位就可以
计算出和模 2<sup>w</sup>。     

考虑一个 4 位数字表示，x=9 和 y=12 的位表示分别为 1001 和 1100。它们的和是 21, 5 位的
表示为 10101。但是如果丢弃最高位，我们就得到 0101，也就是十进制的 5.这就和 21 mod 16 = 5
一致。    

**无符号数加法：**    

![unsigned-addition](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/unsigned-addition.png)    

当执行 C 程序时，不会将溢出作为错误而发信号。不过有的时候，我们可能希望判定是否发生了溢出。   

**检测无符号数加法中的溢出：**   

![detect-unsigned-addition-overflow](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/detect-unsigned-addition-overflow.png)    

模数加法形成了一种数学结构，称为 **阿贝尔群**。也就是说，它是可交换和可结合的。它有一个
单位元 0，并且每个元素有一个加法逆元。考虑 w 位的无符号数的集合，执行加法运算+<sup>u</sup><sub>w</sub>.
对于每个值 x，必然有某个值 -<sup>u</sup><sub>w</sub>x 满足
-<sup>u</sup><sub>w</sub>x +<sup>u</sup><sub>w</sub> x = 0。该加法的逆操作可以表述
如下：    

原理：无符号数求反     

对满足 0 &lt;= x &lt; 2<sup>w</sup> 的任意 x，其 w 位的无符号逆元 -<sup>u</sup><sub>w</sub>x
由下式给出：    

-<sup>u</sup><sub>w</sub> = x    x=0   
                          = 2<sup>w</sup> - x,   x &gt; 0     

看不懂是什么鬼东西。   


### 2.3.2 补码加法

给定在范围 -2<sup>w-1</sup> &lt; x, y &lt;= 2<sup>w-1</sup> - 1 之内的整数值 x 和 y，
它们的和就在范围 -2<sup>w</sup> &lt;= x + y &lt;= 2<sup>w</sup> - 1 之内，要想准确
表示，可能需要 w + 1 位。定义 x+<sup>t</sup><sub>w</sub> y 为整数和 x + y 被截断
w 位的结果，并将这个结果看作是补码数。    

**补码加法：**    

![two's-complement-addition](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/two's-complement-addition.png)    

**检测补码加法中的溢出：**         

对满足 TMin &lt;= x, y &lt;= TMax 的 x 和 y，令 s = x+<sup>t</sup><sub>w</sub> y。
当且仅当 x&gt;0, y &gt; 0，但 s &lt;= 0，计算 s 发生了正溢出。当且仅当 x &lt; 0, y &lt; 0,
但 s &gt;= 0 时，计算 s 发生了负溢出。     


### 2.3.4 无符号乘法

![unsigned-multi](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/unsigned-multi.png)    

### 2.3.5 补码乘法      

![two's-multi](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/two's-multi.png)    

### 2.3.6 乘以常数

以往，在大多数机器上，整数乘法指令相当慢，需要 10 个或者更多的时钟周期，然而其他整数运算，
例如加法，减法，位级运算和移位只需要 1 个时钟周期。因此，编译器使用了一项重要的优化，试着
用移位和加法运算来代替乘以常数因子的乘法。首先，我们考虑乘以 2 的幂的情况，然后再概括成乘以
任意常数。    

乘以 2 的幂这个好理解，就是左移。当然无论是无符号运算还是补码运算，乘以 2 的幂都可能会导致
溢出。   

由于整数乘法比移位和加法的代价要大得多，许多 C 语言编译器试图以移位、加法和减法的组合来消除
很多整数乘以常数的情况。例如，假设一个程序包含表达式 x*14。利用 14 = 2<sup>3</sup> +
2<sup>2</sup> + 2<sup>1</sup>，编译器会将乘法重写为 (x &lt;&lt; 3) + (x &lt;&lt;2) +
(x &lt;&lt; 1)，将一个乘法替换为 3 个移位和 2 个加法。无论 x 是无符号的还是补码，甚至
当乘法会导致溢出时，两个计算都会得到一样的结果。更好的是，编译器还可以利用属性 14 = 2<sup>4</sup>-
2<sup>1</sup>，将乘法重写成 (x&lt;&lt;4) - (x&lt;&lt;1)。    

### 2.3.7 除以 2 的幂

在大多数机器上，整数除法要比整数乘法更慢。除以 2 的幂也可以用移位运算来实现，只不过我们
用的是右移，而不是左移。无符号和补码数分别使用逻辑移位和算术移位来达到目的。    

整数触发总是舍入到零。对于除以 2 的幂的无符号除法来说，除法向下舍入的结果相当于逻辑右移。   

但是对于补码来说情况比较复杂，如果简单地进行算术右移，最后向下舍入的结果并非我们想要的
向零舍入。    

因此我们需要通过在移位之前“偏置”这个值，来修正这种不合适的舍入。    

**除以 2 的幂的补码除法：**   

C 变量 x 和 k 分别为有补码值 x 和无符号数值 k，且 0 &lt;= k &lt; w，则当执行算术移位时，
C 表达式 (x + (1 &lt;&lt; k) - 1) &gt;&gt; k 产生数值 ⌈x / 2<sup>k</sup>⌉。   

注意这里的向上取整其实是向零取整。      

不幸的是，除以 2 的幂的移位运算不能推广到任意常数。   

## 2.4 浮点数

### 2.4.1 二进制小数

理解浮点数的第一步是考虑含有小数值的二进制数字。首先，让我们来看看更熟悉的十进制表示法。
十进制表示法使用如下形式的表示：   

d<sub>m</sub>d<sub>m-1</sub>...d<sub>1</sub>d<sub>0</sub> . d<sub>-1</sub>d<sub>-2</sub>...d<sub>-n</sub>     

其中每个十进制数 d<sub>i</sub> 的取值范围是 0~9，这个表达描述的数值 d 定义如下：   

d = ∑<sup>m</sup><sub>i=-n</sub> 10<sup>i</sup> * d<sub>i</sub>     

数字权的定义与十进制小数点符号相关，这意味着小数点左边的数字的权是 10 的正幂，得到整数值，
而小数点右边的数字的权是 10 的负幂，得到小数值。    

类似，考虑一个形如：    

b<sub>m</sub>b<sub>m-1</sub>...b<sub>1</sub>b<sub>0</sub> . b<sub>-1</sub>b<sub>-2</sub>...b<sub>-n</sub>     

的表示法，其中每个二进制数字，或者称为位，b<sub>i</sub> 的取值范围是 0 和 1，这种表示
方法表示的数 b 定义如下：   

b = ∑<sup>m</sup><sub>i=-n</sub> 2<sup>i</sup> * d<sub>i</sub>     

从等式中很容易地看出，二进制小数点向左移动一位相当于这个数被 2 除。类似，二进制小数点
向右移动一位相当于将该数乘 2。    

注意，形如 0.11...1<sub>2</sub> 的数表示的是刚好小于 1 的数。例如，0.111111<sub>2</sub>
表示 63/64，我们将用简单的表达法，1.0 - ε 来表示这样的数值。    

假定我们仅考虑有限长度的编码，那么十进制表示法不能准确地表达像 1/3 和 5/7 这样的树。类似，
小数的二进制表示法只能表示那些能够被写成 x × 2<sup>y</sup> 的数。其他的值只能被近似地
表示。例如，数字 1/5 可以用十进制小数 0.20 精确表示，不过，我们并不能把它准确地表示为一个
二进制小数，我们只能近似地表示它。   

### 2.4.2 IEEE 浮点表示

表达式 5 × 2<sup>100</sup> 是用 101 后面跟随 100 个零的位模式来表示。    

**IEEE 浮点标准：**    

![ieee-floating-standard](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/ieee-floating-standard.png)    

下图给出了将这三个字段装进字中的两种最常见的格式。在单精度浮点格式（C语言中的 float）中，
s、exp 和 frac 字段分别为 1 位、k = 8 位 和 n = 23 位，得到一个 32 位的表示。在双
精度浮点格式（C语言中的 double）中，s、exp 和 frac 字段分别为 1 位、k = 11 位和 n = 52 位。
得到一个 64 位的表示。    

![standard-floating-expression](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/standard-floating-expression.png)    

给定位表示，根据 exp 的值，被编码的值可以分成三种不同的情况（最后一种情况有两个变种）。下图
说明了单精度格式的情况：    

![type-of-floating-expression](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/type-of-floating-expression.png)    

**情况1：规格化的值**    

这是最普遍的情况。当 exp 的位模式即不全为 0，也不全为 1 时，都属于这类情况。在这种情况中，
阶码字段被解释为以 _偏置_ 形式表示的有符号整数。也就是说，阶码的值是 E = e-Bias，其中 e
是无符号数，其位表示为 e<sub>k-1</sub>...e<sub>1</sub>e<sub>0</sub>，而 Bias 是一个
等于 2<sup>k-1</sup> - 1（单精度是 127，双精度是 1023）的偏置值。由此产生指数的取值范围，
对于单精度是 -126~+127，而对于双精度是 -1022~+1023。     

小数字段 frac 被解释为描述小数值 f，其中 0 &lt;= f &lt; 1，其二进制表示为 0.f<sub>n-1</sub>
...f<sub>1</sub>f<sub>0</sub>，也就是二进制小数点在最高有效位的左边。尾数定义为 M = 1 + f。
有时，这种方式也叫做隐含的以 1 开头的表示，因为我们可以把 M 看成一个二进制表达式
1.f<sub>n-1</sub>f<sub>n-2</sub>...f<sub>0</sub> 的数字。既然我们总是能够调整阶码 E，
使得尾数 M 在范围 1 &lt;= M &lt; 2 之中（假设没有溢出），那么这种表示方法是一种轻松获得
一个额外精度位的技巧。既然第一位总是等于 1，那么我们就不需要显示地表示它。   

**情况2：非规格化的值**   

当阶码域为全 0 时，所表示的数是非规格化形式。在这种情况下，阶码值是 E = 1 - Bias，而
尾数的值是 M = f，也就是小数字段的值，不包含隐含的开头的 1。     

非规格化数有两个用途。首先，它们提供了一种表示数值 0 的方法，因为使用规格化数，我们必须
总是使 M &gt;= 1，因此我们就不能表示0。实际上，+0.0 的浮点表示的位模式为全 0：符号位
是0，阶码字段全为 0，而小数域也全为 0，这就得到了 M = f = 0。令人奇怪的是，当符号位
为 1，而其他域全为 0 时，我们得到值 -0.0。根据 IEEE 的浮点格式，值 +0.0 和 -0.0 在某些
方面被认为是不同的，而在其他方面是相同的。    

非规格化数的另外一个功能是表示那些非常接近于 0.0 的数。它们提供了一种属性，称为逐渐溢出，
其中，可能的数值分布均匀地接近于0.0。    

**情况3：特殊值**    

最后一类数值是当阶码全为 1 的时候出现的。当小数域全为 0 时，得到的值表示无穷，当 s = 0
时是 +∞，或者当 s = 1 时是 -∞。当我们把两个非常大的数相乘，或者除以零时，无穷能够表示
溢出的结果。当小数域为非零时，结果值被称为 NaN。    

### 2.4.3 数字示例

k 位阶码和 n 位小数的浮点表示的一般属性如下：    

+ 值 +0.0 总有一个全为 0 的位表示
+ 最小的正非规格化值的位表示，是由最低有效位为 1，而其他所有位为 0 构成的。它具有小数（和
尾数）值 M = f = 2<sup>-n</sup> 和阶码值 E = -2<sup>k-1</sup> + 2。
+ 最大的非规格化值的位模式是由全为 0 的阶码字段和全为 1 的小数字段组成的。它有小数（和尾数）
值 M = f = 1 - 2<sup>-n</sup> 和阶码值 E = -2<sup>k-1</sup> + 2。    
+ 最小的正规格化值的位模式的阶码字段的最低有效位为 1，其他为全为0,。它的尾数值 M = 1，
而阶码值 E = -2<sup>k-1</sup> + 2。   
+ 值 1.0 的位表示的阶码字段除了最高有效位等于 1 以外，其他位都等于 0。它的尾数值是 M =1，
而它的阶码值是 E = 0.
+ 最大的规格化值的位表示的符号位为 0，阶码的最低有效位等于 0，其他位等于 1。它的小数值
f = 1 - 2<sup>-n</sup>，尾数 M = 2 - 2<sup>-n</sup>。它的阶码值 E = 2<sup>k-1</sup> -1.

### 2.4.4 舍入

因为表示方法限制了浮点数的范围和精度，所以浮点运算只能近似地表示实数运算。因此，对于值 x，
我们一般想用一种系统的方法，能够找到 “最接近的” 匹配值 x'，它可以用期望的浮点形式表示出来。
这就是 **舍入** 运算的任务。一个关键问题是在两个可能的中间确定舍入方向。IEEE 浮点格式定义
了四种不同的 **舍入方式**。默认的方法时找到最接近的匹配，而其他三种可用于计算上界和下界。    

下表举例说明了四种舍入方式。向偶数舍入，也被称为向最接近的值舍入，是默认的方式，试图找到
一个最接近的匹配值。因此，它将 1.40 美元舍入成 1，而将 1.60 美元舍入成 2，因为它们是
最接近的整数美元值。唯一的设计决策是确定两个可能结果中间数值的舍入效果。向偶数舍入方式
采用的方法时：它将数字向上或向下舍入，使得结果的最低有效数字是偶数。因此，这种方法将 1.5
美元和 2.5 美元都舍入成 2 美元。   


方式 | 1.40 | 1.60 | 1.50 | 2.50 | -1.50
---------|----------|---------|---------|---------|---------
 向偶数舍入 | 1 | 2 | 2 | 2 | -2
 向零舍入 | 1 | 1 | 1 | 2 | -1
 向下舍入 | 1 | 1 | 1 | 2 | -2
 向上舍入 | 2 | 2 | 2 | 3 | -1

### 2.4.6 C 语言中的浮点数

当在 int、float 和 double 格式之间进行强制类型转换时，程序改变数值和位模式的原则如下
（假设 int 是 32 位的）：    

+ 从 int 转换成 float，数字不会溢出，但是可能被舍入
+ 从 int 或 float 转换成 double，因为 double 有更大的范围，也有更高的精度，所以能够保留
精确的数值
+ 从 double 转换成 float，因为范围要小一些，所以只可能溢出无穷大。另外，由于精确度较小，
它还可能被舍入。   
+ 从 float 或者 double 转换成 int，值将会向零舍入。进一步来说，值可能会溢出。

# 第三章 程序的机器级表示

计算机执行 **机器代码**，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的
数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过
一系列的阶段生成机器代码。     

用高级语言编写的程序可以在很多不同的机器上编译和执行，而汇编代码则是与特定机器密切相关的。    

## 3.2 程序编码

假设一个 C 程序，有两个文件 p1.c 和 p2.c。我们用 Unix 命令行编译这些代码：   

`linux > gcc -Og -o p p1.c p2.c`    

编译选项 -Og 告诉编译器使用会生成符合原始 C 代码整体结构的机器代码的优化等级。使用较高
级别优化产生的代码会严重变形。实际中，从得到的程序的性能考虑，较高级别的优化（例如，以
选择 -O1 或 -O2 指定）被认为是较好的选择。    

实际上 gcc 命令调用了一整套的程序，将源代码转换成可执行代码。首先，C *预处理器* 扩展源代码，
插入所有用 #include 命令指定的文件，并扩展所有用 #define 声明指定的宏。其次，*编译器*
产生两个源文件的汇编代码，名字分别为 p1.s 和 p2.s。接下来，*汇编器* 会将汇编代码转化
成二进制目标代码文件 p1.o 和 p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，
但是还没有填入全局值的地址。最后，*链接器* 将两个目标代码文件与实现库函数的代码合并，并产生
最终的可执行代码文件 p。可执行代码是我们要考虑的机器代码的第二种形式，也就是处理器执行的代码
格式。    

### 3.2.1 机器级代码

计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，
其中两种抽象尤为重要。第一种是由 _指令集体系结构或指令集架构_(Instruction Set Architecture, ISA)
来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。
大多数 ISA，将程序的行为描述成好像每条指令都是按顺序执行的。处理器的硬件远比描述的精细复杂，
它们并发地执行许多指令，但是可以采取措施保证整体行为与 ISA 指定的顺序执行的行为完全一致。
第二种抽象是，机器级程序使用的内存地址是虚拟地址。    

x86-64 的机器代码和原始的 C 代码差别非常大。一些通常对 C 语言程序员隐藏的处理器状态都是可见的：   

+ _程序计数器_ (在 x86-64 中用 %rip 表示)给出将要执行的下一条指令在内存中的地址。
+ 整数 _寄存器_ 文件包含 16 个命名的位置，分别存储 64 位的值。这些寄存器可以存储地址或
整数数据。有的寄存器被用来记录某些重要的程序状态。
+ 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件
变化，比如说用来实现 if 和 while 语句。
+ 一组向量寄存器可以存放一个或多个整数或浮点数值。    

虽然 C 语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单地
将内存看成一个很大的、按字节寻址的数组。C 语言中的聚合数据类型，例如数组和结构体，在机器代码
中用一组连续的的字节表示。即使是对标量数据类型，汇编代码也不区分有符号或无符号整数，不区分
各种类型的指针，甚至不区分指针和整数。    

程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回时的运行时
栈，以及用户分配的内存块。    

### 3.2.2 代码示例

假设我们写了一个 C 语言代码文件 mstore.c，包含如下的函数定义：   

```c
long mult2(long, long);

void multstore(long x, long y, long *dest) {
  long t = mult2(x, y);
  *dest = t;
}
```   

在命令行上使用 -S 选项，就能看到 C 语言编译器产生的汇编代码：   

`linux > gcc -Og -S mstore.c`    

这会使 GCC 产生一个汇编文件 mstore.s。    

汇编代码文件包含各种声明，包括下面几行：    

```asm
multstore:
  pushq   %rbx
  movq    %rdx, %rbx
  call    mult2
  movq    %rax, (%rbx)
  popq    %rbx
  ret
```    

完整的本地测试时生成的文件内容在下一小节。 

如果我们使用 -c 命令行选项，GCC 会编译并汇编该代码：   

`linux > gcc -Og -c mstore.c`     

要查看机器代码文件的内容，有一类称为 _反汇编器_ 的程序非常有用。这些程序根据机器代码产生一种
类似于汇编代码的格式，在 Liunx 系统中，使用 objdump -d 充当这个角色：   

`linux > objdump -d mstore.o`    

结果如下（这里，我们在左边增加了行号，在右边增加了斜体表示的注解）：    

```
1   0000000000000000 <multstore>:
    offset    Bytes             Equivalent assembly language
2       0:    53                push    %rbx
3       1:    48 89 d3          mov     %rdx,%rbx
4       4:    e8 00 00 00 00    callq   9 <multstore+0x9>
5       9:    48 89 03          mov     %rax,(%rbx)
6       c:    5b                pop     %rbx
7       d:    c3                retq
```     

本地测试时候打印出的内容如下：    

```

mstore.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <multstore>:
   0:	53                   	push   %rbx
   1:	48 89 d3             	mov    %rdx,%rbx
   4:	e8 00 00 00 00       	callq  9 <multstore+0x9>
   9:	48 89 03             	mov    %rax,(%rbx)
   c:	5b                   	pop    %rbx
   d:	c3                   	retq   
```    

其中一些关于机器代码和它的反汇编表示的特性值得注意：   

+ x86-64 的指令长度从 1 到 15 个字节不等。常用的指令以及操作数较少的指令所需的字节数少，
而那些不太常用或操作数较多的指令所需的字节数较多
+ 设计指令格式的方式是，从某个给定的位置开始，可以将字节唯一地解码成机器指令。例如，只有
指令 pushq %rbx 是以字节值 53 开头的
+ 反汇编器使用的指令命名规则与 GCC 生成的汇编代码使用的有些细微的差别。在我们的示例中，
它省略了很多指令结尾的 'q'。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器
给 call 和 ret 指令添加了 'q' 后缀，同样，省略这些后缀也没有问题    

### 3.2.3 关于格式的注解

继续来看我们之前使用 gcc 生成的汇编代码文件 mstore.s：    

```asm
	.file	"mstore.c"
	.text
	.globl	multstore
	.type	multstore, @function
multstore:
.LFB0:
	.cfi_startproc
	pushq	%rbx
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
	movq	%rdx, %rbx
	call	mult2
	movq	%rax, (%rbx)
	popq	%rbx
	.cfi_def_cfa_offset 8
	ret
	.cfi_endproc
.LFE0:
	.size	multstore, .-multstore
	.ident	"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.10) 5.4.0 20160609"
	.section	.note.GNU-stack,"",@progbits
```    

注意上面是本地测试时候生成的汇编代码，书上和这个有点差别，但差别不大。    

所以以 '.' 开头的行都是指导汇编器和链接器工作的伪指令。我们通常可以忽略这些行。     

对于我们的示例，带解释的汇编代码如下：    

```
    void multstore(long x, long y, long *dest)
    x in %rdi, y in %rsi, dest in %rdx
1   multstore:
2     pushq    %rbx           Save %rbx
3     movq     %rdx, %rbx     Copy dest to %rbx
4     call     mult2          Call mult2(x, y)
5     movq     %rax, (%rbx)   Store result at *dest
6     popq     %rbx           Restore %rbx
7     ret                     Return
```    

**ATT 和 Inter 汇编代码格式**    

我们的表述是 ATT 格式的汇编代码。一些编程工具，包括微软的工具以及来及 Inter 的文档，其汇编
代码都是 Inter 格式的，这两种格式在许多方面有所不同，例如，使用下述命令行，gcc 可以产生 Inter
格式的代码：   

`linux > gcc -Og -S -masm=inter mstore.c`    

得到如下代码：   

```asm
multstroe:
  push   rbx
  mov    rbx, rdx
  call   mult2
  mov    QWORD PTR [rbx], rax
  pop    rbx
  ret
```   

我们看到 Inter 和 ATT 格式在如下方面有所不同：   

+ Inter 代码省略了指示大小的后缀
+ Inter 代码省略了寄存器名字前面的 % 符号
+ Inter 代码用不同的方式来描述内存中的位置，例如是 QWORD PTR [rbx] 而不是 (%rbx)
+ 在带有多个操作数的指令情况下，列出操作数的顺序相反。    

## 3.3 数据格式

由于是从 16 位体系结构扩展成 32 位的，Inter 用术语 "字(word)" 表示 16 位数据类型。因此，
称 32 位数为 "双字(double words)"，称 64 位数为 "四字(quad words)"。    

大多数 GCC 生成的汇编代码都有一个字符的后缀，表明操作数的带下。例如，数据传送指令有四个变种：
movb（传送字节），movw（传送字），movl（传送双字）和 movq（传送四字），后缀 l 用来表示
双字，因为 32 位数被看成是 long word。    

## 3.4 访问信息

一个 64 位 CPU 包含一组 16 个存储 64 位值的 **通用目的寄存器**。这些寄存器用来存储整数
数据和指针。它们的名字都以 %r 开头，不过后面还跟着一些不同的命名规则的名字，这是由于指令
集历史演化造成的。最初的 8086 有 8 个 16 位寄存器，即图中的 %ax 到 %bp。扩展到 IA32
架构时，这些寄存器扩展到了 32 位，标号从 %eax 到 %ebp。扩展到 x86-64 后，原来的 8 个
寄存器扩展成 64 位，标号从 %rax 到 %rbp。除此之外，还增加了 8 个新的寄存器，它们的标号是
按照新的命名规则制定的：从 %r8 到 %r15。     

![universal-registers](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/universal-registers.png)    

如图中嵌套的方框标明的，指令可以对这 16 个寄存器的低位字节中存放的不同大小的数据进行操作，
字节级操作可以访问最低的字节，16 位操作可以访问最低的 2 个字节，32 位操作可以访问最低的
4 个字节。    

在后面的章节中，我们会展现很多指令，复制和生成 1 字节、2字节、4字节和 8字节值。当这些指令
以寄存器作为目标时，对于生成小于 8 字节结果的指令，寄存器中剩下的字节会怎么样，对此有两条
规则：生成 1 字节和 2 字节数字的指令会保持剩下的字节不变；生成 4 字节数字的指令会把高位 4
个字节置为 0.    

### 3.4.1 操作数指示符

大多数指令有一个或多个 **操作数**(operand)，指示出执行一个操作中要使用的源数据值，以及放置
结果的目的位置。源数据值可以以常数形式给出，或是从寄存器或内存中读出。结果可以存放在寄存器或
内存中。因此，各种不同的操作数的可能性被分为三种类型。第一种类型是 **立即数**(immediate)，
用来表示常数值。在 ATT 格式的汇编代码中，立即数的书写方式是 '$' 后面跟一个用标准 C 表示法
表示的整数，比如 $-577 或 $0x1F。不同指令允许的立即数值范围不同，汇编器会自动选择最紧凑的
方式进行数值编码。第二种类型是 **寄存器**(register)，它表示某个寄存器的内容。在下图中，我们
用符号 r<sub>a</sub> 来表示任意寄存器 a，用引用 R[r<sub>a</sub>] 来表示它的值，这是将
寄存器集合看成一个数组 R，用寄存器标识符作为索引。    

第三类操作数是 **内存** 引用，它会根据计算出来的地址访问某个内存位置。我们用符号 M<sub>b</sub>[Addr] 表示对存储在内存中从地址 Addr 开始的 b 个字节值的引用。    

如图所示，有多种不同的 **寻址模式**，允许不同形式的内存引用。表中底部用语法 Imm(r<sub>b</sub>,
r<sub>i</sub>, s)表示的是最常用的形式。这样的引用有四个组成部分：一个立即数偏移 Imm，一个
基址寄存器 r<sub>b</sub>，一个变址寄存器 r<sub>i</sub> 和一个比例因子 s，这里 s 必须
是 1,2,4 或者 8。基址和变址寄存器都必须是 64 位寄存器。有效地址被计算为 Imm +
R[r<sub>b</sub>] + R[r<sub>i</sub>] * s。    

![operand-form](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/operand-form.png)    

**练习题3.1** 假设下面的值存放在指明的内存地址和寄存器中：    


地址 | 值
----------|---------
 0x100 | 0xFF
 0x104 | 0xAB
 0x108 | 0x13
 0x10c | 0x11


寄存器 | 值
----------|---------
 %rax | 0x100
 %rcx | 0x1
 %rdx | 0x3

填写下表，给出所示操作数的值：    

操作数 | 值
----------|---------
 %rax | 0x100
 0x104 | 0xAB
 $0x108 | 0x108
 (%rax) | 0xFF
 4(%rax) | 0xAB
 9(%rax, %rdx) | 0x11
 260(%rcx, %rdx) | 0x13
 0xFC(, %rcx, 4) | 0xFF
 (%rax, %rdx, 4) | 0x11

### 3.4.2 数据传送指令

数据传送指令是将数据从一个位置复制到另一个位置的指令。我们会介绍多种不同的数据传送指令，它们
或者源和目的类型不同，或者执行的转换不同，或者具有的一些副作用不同。在我们的讲述中，把许多
不同指令划分成指令类，每一类中的指令执行相同的操作，只不过操作数大小不同。    

下表列出了最简单形式的数据传送指令 —— MOV 类。这些指令把数据从源位置复制到目的位置，不做
任何变化。MOV 类由四条指令组成：movb, movw, movl 和 movq。     


指令 | 效果 | 描述
---------|----------|---------
 MOV  S, D | D ← S | 传送
 movb |  | 传送字节
 movw |  | 传送字
 movl |  | 传送双字
 movq |  | 传送四字
 movabsq  I, R | R ← I | 传送绝对的四字

源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个位置，要么是一个
寄存器或者是一个内存地址。x86-64 加了一条限制，传送指令的两个操作数不能都指向内存位置。将
一个值从一个内存位置复制到另一个内存位置需要两条指令——第一条指令将源值加载到寄存器中，第二条
将该寄存器值写入到目的位置。   

上表中最后一条指令是处理 64 位立即数数据的。常规的 movq 指令只能以表示为 32 位补码数字
的立即数作为源操作数，然后把这个值符号扩展到 64 位的值，放到目的位置。movabsq 指令能够
以任意 64 位立即数值作为源操作数，并且只能以寄存器作为目的。   

以下两表记录的是两类数据移动指令，在将较小的源值复制到较大的目的时使用。所有这些指令都把
数据从源（在寄存器或内存中）复制到目的寄存器。MOVZ 类中的指令把目的中剩余的字节填充为 0，
而 MOVS 类中的指令通过符号扩展来填充。可以观察到，每条指令名字的最后两个字符都是大小指示
符：第一个字符指定源的大小，而第二个指明目的地的大小。    


指令 | 效果 | 描述
---------|----------|---------
 MOVZ  S, R | R ← 零扩展(S) | 以零扩展进行传送
 movzbw |  | 字节传送到字
 movzbl |  | 字节传送到双字
 movzwl |  | 字传送到双字
 movzbq |  | 字节传送到四字
 movzwq |  | 字传送到四字    

话说为什么没有双字到四字的传送？？因为完全可以用 movl 指令实现。     

指令 | 效果 | 描述
---------|----------|---------
 MOVS  S, R | R ← 符号扩展(S) | 以符号扩展进行传送
 movsbw |  | 字节传送到字
 movsbl |  | 字节传送到双字
 movswl |  | 字传送到双字
 movsbq |  | 字节传送到四字
 movswq |  | 字传送到四字  
 movslq |  | 双字传送到四字
 cltq | %rax ← 符号扩展(%eax) | 把 %eax 符号扩展到 %rax

### 3.4.3 数据传送示例

```c
long exchange(long *xp, long y) {
  long x = *xp;
  *xp = y;
  return x;
}
```   

相应的汇编代码：   

```asm
// long exchange(long *xp, long y)
// xp in %rdi, y in %rsi
exchange:
  movq (%rdi), %rax   // Get x at xp, Set as return value.     
  movq %rsi, (%rdi)   // Store y at xp.
  ret                 // Return
```    

参考之前给出了通用寄存器的作用图，rax 就是返回值，rdi 和 rsi 分别保存前两个参数。   

### 3.4.4 压入和弹出栈数据

最后两个数据传送操作可以将数据压入程序栈中，以及从程序栈中弹出数据。栈指针 %rsp 保存着栈顶
元素的地址。    


指针 | 效果 | 描述
---------|----------|---------
 pushq S | R[%rsp] ← R[%rsp]-8; M[R[%rsp]] ← S | 将四字压入栈
 popq D | D ← M[R[%rsp]];  R[%rsp] ← R[%rsp] + 8 | 将四字弹出栈    

将一个四字值压入栈中，首先要将栈指针减 8，然后将值写到新的栈顶地址。因此，指令 pushq %rbp
的行为等价于下面两条指令：   

```asm
subq    $8, %rsp      // 递减栈指针
movq    %rbp, (%rsp)
```    

它们之间的区别是在机器代码中 pushq 指令编码为 1 个字节，而上面那两条指令要 8 个字节。    

弹出一个四字的操作包括从栈顶位置读出数据，然后将栈指针加 8，因此指令 popq 5rax 等价于
下面两条指令：   

```asm
movq  (%rsp), %rax
addq $8, %rsp
```    

## 3.5 算术和逻辑操作

下表列出了 x86-64 的一些整数和逻辑操作。大多数操作都分成了指令类，这些指令类有各种带
不同大小操作数的变种。例如指令类 ADD 由四条加法指令组成：addb, addw, addl, addq。
这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。    


指令 | 效果 | 描述
---------|----------|---------
 leaq  S, D | D ← &S | 加载有效地址
 INC D | D ← D + 1 | 加 1
 DEC D | D ← D - 1 | 减 1
 NEG D | D ← -D | 取负
 NOT D | D ← ~D | 取补
 ADD S, D | D ← D + S | 加
 SUB S, D | D ← D - S | 减
 IMUL S, D | D ← D * S | 乘
 XOR S, D | D ← D ^ S | 异或
 OR S, D | D ← D \| S | 或
 AND S, D | D ← D & S | 与
 SAL k, D | D ← D &lt;&lt; k | 左移
 SHL k, D | D ← D &lt;&lt; k | 左移（等同于 SAL）
 SAR k, D | D ← D &gt;&gt; k | 算术右移
 SHR k, D | D ← D &gt;&gt; k | 逻辑右移

### 3.5.1 加载有效地址

加载有效地址(load effective address)指令 leaq 实际上是 movq 指令的变形。它的指令形式是从内存读数据到寄存器，但它
实际上根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置
读入数据，而是将有效地址写入到目的操作数。在上面的表中我们用 C 语言的地址操作符说明这种计算。
这条指令可以为后面的内存引用产生指针。    

另外，它还可以简洁地描述普通的算术操作，例如，如果寄存器 %rdx 的值为 x，那么指令
leaq 7(%rdx, %rdx, 4), %rax 将设置寄存器 %rax 的值为 5x+7。   

### 3.5.2 一元和二元操作

第三组是二元操作，其中，第二个操作数既是源又是目的。   

**练习题3.8** 假设下面的值存放在指定的内存地址和寄存器中：   

地址 | 值
----------|---------
 0x100 | 0xFF
 0x108 | 0xAB
 0x110 | 0x13
 0x118 | 0x11


寄存器 | 值
----------|---------
 %rax | 0x100
 %rcx | 0x1
 %rdx | 0x3

填写下表，给出下面指令的效果，说明将被更新的寄存器或内存位置，以及得到的值

指令 | 目的 | 值
----------|---------|---------
 addq %rcx, (%rax) | 0x100 | 0x100
 subq %rdx, 8(%rax) | 0x108 | 0xA8
 imulq $16, (%rax, %rdx, 8) | 0x118 | 0x110
 incq 16(%rax) | 0x110 | 0x14
 decq %rcx | %rcx | 0x0
 subq %rdx, %rax | %rax | 0xFD   

### 3.5.3 移位操作

移位量可以是一个立即数，或者放在单字节寄存器 %cl 中。原则上来说，1 个字节的移位量使得移位
量的编码范围可以达到 255，x86-64 中，移位操作对 w 位长度数据值进行操作，移位量是由 %cl
寄存器的低 m 位决定的，这里 2<sup>m</sup> = w。高位会被忽略。    

### 3.5.5 特殊的算术操作

两个 64 位有符号或无符号整数相乘得到的乘积需要 128 位来表示。x86-64 对 128 位数提供
有限的支持，Inter 把 16 字节的数称为八字(oct word)。    

![oct-word-mul](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/oct-word-mul.png)    

x86-64 指令集提供了两条不同的“单操作数”乘法指令，以计算两个 64 位值的全 128 位乘积——
一个是无符号乘法 mulq，而另一个是补码乘法 imulq。这两条指令都要求一个参数必须在寄存器 %rax
中，而另一个作为指令的源操作数给出。然后乘积存放在寄存器 %rdx(高64位)和 %rax(低64位)中。    

```c
#include <inttypes.h>

typedef unsigned __int128 uint128_t;

void store_uprod(unit128_t *dest, uint64_t x, uint64_t y) {
  *dest = x * (uint128_t) y;
}
```   

GCC 生成的汇编代码如下：   

```asm
// dest in %rdi, x int %rsi, y in %rdx
store_uprod:
  movq    %rsi, %rax    // Copy x to multiplicand
  mulq    %rdx          // Multiply by y
  movq    %rax, (%rdi)  // Store lower 8 bytes at dest
  movq    %rdx, 8(%rdi) // Store upper 8 bytes at dest+8
  ret
```    

前面的算术运算表没有列出除法或取模操作。这些操作是由单操作数除法指令来提供的，类似于单操作数
乘法指令。有符号除法指令 idivq 将寄存器 %rdx（高 64 位）和 %rax（低 64 位）中的 128 位
数作为被除数，而除数作为指令的操作数给出。指令将商存储在寄存器 %rax 中，将余数存储在寄存器
%rdx 中。    

## 3.6 控制

机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流
或者数据流。    

与数据相关的控制流是实现有条件行为的更一般和更常见的方法，所以我们先来介绍它。通常，C 语言
中的语句和机器代码中的指令都是按照它们在程序中出现的次序，顺序执行的。用 **jump** 指令可以
改变一组机器代码执行的执行顺序，jump 指令指定控制应该被传递到程序的某个其他部分。   

### 3.6.1 条件码

除了整数寄存器，CPU 还维护着一组单个位的 **条件码**(condition code)寄存器，它们描述了
最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。最常用的条件码有：   

+ CF：进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出
+ ZF：零标志。最近的操作得出的结果为 0
+ SF：符号标志。最近的操作得到的结果为负数
+ OF：溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出    

比如说，假设我们用一条 ADD 指令完成等价于 C 表达式 t=a+b 的功能，这里变量 a, b 和 t
都是整型的。然后，根据下面的 C 表达式来设置条件码：   

CF   (unsigned) t &lt; (unsigned) a    无符号溢出   
ZF   (t==0) 零    
SF   (t &lt; 0) 负数   
OF   (a &lt; 0 == b &lt; 0) && (t &lt; 0 != a &lt; 0) 有符号溢出    

leaq 指令不改变任何条件码，因为它是用来进行地址计算的。除此之外，3.5 第一小节前的那个表中
列出的所有指令都会设置条件码。对于逻辑操作，例如 XOR，进位标志和溢出标志会设置成 0。对于
移位操作，进位标志将设置为最后一个被移出的位，而溢出标志设置为 0.INC 和 DEC 指令会设置
溢出和零标志，但是不会改变进位标志。    

除此之外，还有两类指令，它们只设置条件码而不改变任何其他寄存器。如图所示，CMP 指令根据
两个操作数之差来设置条件码。除了只设置条件码而不更新目的寄存器之外，CMP 指令与 SUB 指令
的行为是一样的。TEST 指令的行为与 AND 指令一样，除了它们只设置条件码而不改变目的寄存器
的值。   

![cmp-test](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/cmp-test.png)    

### 3.6.2 访问条件码

条件码通常不会直接读取，常用的使用方法有三种：1)可以根据条件码的某种组合，将一个字节设置
为 0 或者 1, 2)可以条件跳转到程序的某个其他的部分，3)可以有条件地传送数据。对于第一种
情况，下图描述的指令根据条件码的某种组合，将一个字节设置为 0 或者 1。我们将这一整类指令
称为 **SET** 指令；它们之间的区别在于它们考虑的条件码的组合是什么，这些指令名字的不同后缀
指明了它们所考虑的条件码的组合。例如，指令 setl 和 setb 表示“小于时设置(set less)” 和
“低于时设置(set below)”。    

![set-instructions](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/set-instructions.png)    


一条 SET 指令的目的操作数是低位单字节寄存器元素之一，或者一个字节的内存之一，指令会将这个
字节设置成 0 或者 1。为了得到一个 32 位或 64 位结果，我们必须对高位清零。    

一个计算 C 语言表达式 a &lt; b 的典型指令序列如下所示：    

```asm
// int comp(data_t a, data_t b)
// a in %rdi, b in %rsi
comp:
  cmpq  %rsi, %rdi   // Compare a:b
  setl  %al          // Set low-order byte if %eax to 0 or 1
  