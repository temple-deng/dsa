# 第 1 章 计算机系统漫游

## 1.2 程序被其他程序翻译成不同的格式    

```c
// hello.c
#include <stdio.h>

int main() {
  printf("hello world\n");
  return 0;
}
```    

hello 程序的生命周期是从一个高级 C 语言程序开始的，因为这种形式能够被人读懂。然后，为了
在系统上运行 hello.c 程序，每条 C 语句必须被其他程序转化为一系列的低级 **机器语言** 指令。
然后这些指令按照一种称为 **可执行目标程序** 的格式打好包，并以二进制磁盘文件的形式存放
起来。目标程序也称为 **可执行目标文件**。   

在 Unix 系统上，从源文件到目标文件的转化是由编译器驱动程序完成的：   

`linux> gcc -o hello hello.c`    

这个翻译过程可分为四个阶段完成，执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）
一起构成了 **编译系统**：    

![compilation-system](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/compilation-system.png)   

+ _预处理阶段_。预处理器 cpp 根据以字符 # 开头的命令，修改原始的 C 程序。比如 hello.c
中的第 1 行的 `#include <stdio.h>` 命令告诉预处理器读取系统头文件 stdio.h 的内容，并把
它直接插入程序文本中。结果就得到了另一个 C 程序，通常是以 .i 作为文件扩展名。
+ _编译阶段_。编译器 ccl 将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言
程序。该程序包含函数 main 的定义，如下所示：   
```asm
1  main:
2    subq     $8, %rsp
3    movl     $.LCO, %edi
4    call     puts
5    movl     $0, %eax
6    addq     $8. %rsp
7    ret
```    
+ _汇编阶段_。接下来，汇编器 as 将 hello.s 翻译成机器语言指令，并把这些指令打包成一种
叫做 **可重定位目标程序**(relocatable object program)的格式，并将结果保存在目标文件
hello.o 中。hello.o 文件是一个二进制文件，它包含的 17 个字节是函数 main 的指令编码。
+ _链接阶段_。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中。而这个
文件必须以某种方式合并到我们的 hello.o 程序中。链接器 ld 就负责处理这种合并。结果就得到
hello 文件，它是一个可执行目标文件，可以被加载到内存中，由系统执行。   

看这个意思，可**程序一般是指一种文件的格式，而可\*\*文件就是最后的某种文件。   

## 1.4 处理器读并解释储存在内存中的指令

### 1.4.1 系统的硬件组成

![system-hardware](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/system-hardware.png)   

1. **总线**    

贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被
设计成传送定长的字节块，也就是 **字**(word)。字中的字节数（即字长）是一个基本的系统参数，
各个系统中都不尽相同，现在大多数机器字长要么是 4 个字节，要么是 8 个字节。    

2. **I/O 设备**    

每个 I/O 设备都通过一个 **控制器** 或 **适配器** 与 I/O 总线相连。控制器与适配器之间的
区别主要在于它们的封装方式。控制器是 I/O 设备本身或者系统的主板上的芯片组。而适配器则
是一块插在主板插槽上的卡。无论如何，它们的功能都是在 I/O 总线和 I/O 设备之间传递信息。    

3. **处理器**    

处理器的核心是一个大小为一个字的存储设备（或寄存器），称为 **程序计数器**(PC)。在任何
时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。     

从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数
器，使其指向下一条指令。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列
的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，
然后更新 PC，使其指向下一条指令。    

这样的简单操作并不多，它们围绕着主存、寄存器文件和 **算术/逻辑单元**(ALU) 进行。寄存器
文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU 计算
新的数据和地址值。下面是一些简单操作的例子，CPU 在指令的要求下可能会执行这些操作：   

+ **加载**：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。
+ **存储**：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。
+ **操作**：把两个寄存器的内容复制到 ALU，ALU 对这两个字做算术运算，并将结果存放到一个
寄存器中，以覆盖该寄存器中原来的内容。
+ **跳转**：从指令本身中抽取一个字，并将这个字复制到程序计数器中，以覆盖 PC 中原来的值。    

处理器看上去是他的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速
程序的执行。因此，我们将处理器的 **指令集架构** 和处理器的 **微体系结构** 区分开来：
指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。   

## 1.5 高速缓存至关重要

一个典型的寄存器文件只存储几百字节的信息。看这个意思，一个单个寄存器应该就是一个字长的
大小，而一个寄存器文件通常是多个寄存器的集合。    

位于处理器芯片的 **L1 高速缓存** 的容量可以达到数万字节，访问速度几乎和访问寄存器文件
一样快。一个容量为数十万到数百万字节的更大的 **L2 高速缓存** 通过一条特殊的总线连接到
处理器。进程访问 L2 高速缓存的时间要比访问 L1 高速缓存的时间长 5 倍。L1 和 L2 高速缓存
使用一种叫做静态随机访问存储器(SRAM)的硬件技术实现的。

## 1.9 重要主题

### 1.9.2 并发和并行

我们用的术语 **并发** 是一个通用的概念，指一个同时具有多个活动的系统；而术语 **并行**
指的是用并发来使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用。在此，我们
按照层次结构中由高到低的顺序重点强调三个层次。    

1. **线程级并发**     

超线程，有时称为 **同时多线程**，是一项允许一个 CPU 执行多个控制流的技术。它涉及 CPU 某些
硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份，比如执行浮点算术运算
的单元。常规的处理器需要大约 20 000 个时钟周期做不同线程间的切换，而超线程的处理器可以在
单个周期的基础上决定要执行哪一个资源。这使得 CPU 能够更好地利用它的处理资源。比如，假设
一个线程必须等到某些数据被装载到高速缓存中，那 CPU 就可以继续去执行另一个线程。     

那也就是说可能我们装载程序的时候，就把不同的线程内容装载到不同的硬件备份中，从这个角度来看，
执行单元应该都只有一份，但一些存储单元应该都是有两份，这样当线程切换时，我们压根不用从内存
中保存和调出线程的上下文，而是直接让执行单元执行另一个 PC 中保存的指令即可。   

2. **指令级并行**    

首先我们需要明确一点，时钟周期和指令并不是一一对应的，并不是说一个时钟周期执行一条指令，
另外一条指令和其要执行的操作也不是一一对应的，一条指令可能要完成多个操作。   

在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为 **指令级并行**。最近的处理器
可以保持某个时钟周期 2~4 条指令的执行速率。其实每条执行从开始到结束需要长得多的时间，大约
20 个或者更多周期，但是处理器使用了非常多的聪明技巧来同时处理多达 100 条指令。    

在流水线中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，
每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。    

如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为 **超标量** 处理器。大多数
现代处理器都支持超标量操作。   

3. **单指令、多数据并行**    

在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种
方式称为 **单指令、多数据**，即 SIMD 并行。    


# 第一部分 程序结构和执行

我们对计算机系统的探索是从学习计算机本身开始的，它由处理器和存储器子系统组成。在核心部分，
我们需要方法来表示基本数据类型，比如整数和实数运算的近似值。然后，我们考虑机器级指令如何
操作这样的数据，以及编译器又如何将 C 程序翻译成这样的指令。接下来，研究几种实现处理器的
方法，帮助我们更好地了解硬件资源如何被用来执行指令。    

# 第 2 章 信息的表示和处理

我们研究三种最重要的数字表示。*无符号* (unsigned)编码基于传统的二进制表示法，表示大于或者
等于零的数字。*补码* (two's-complement)编码是表示有符号整数的最常见的方式。*浮点数* (floating-point)
编码是表示实数的科学计数法的以 2 为基数的版本。   

计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以致不能表示时，某些计算
就会溢出。例如，在 int32 类型情况下，计算表达式 200\*300\*400*500 会得出结果 -884 901 888.    

另一方面，整数的计算机运算满足人们所熟知的真正整数运算的许多性质。例如，利用乘法的结合律
和交换律，计算下面任何一个 C 表达式，都会得出一个结果 -884 901 888:   

+ (500 * 400) * (300 * 200)
+ ((500 * 400) * 300) * 200
+ ((200 * 500) * 300) * 400
+ 400 * (200 * (300 * 500))    

计算机可能没有产生期望的结果，但是至少它是一致的！    

浮点运算有完全不同的数学属性。虽然溢出会产生特殊的值 +∞，但是一组正数的乘积总是正的。由于
表示的精度有限，浮点运算是不可结合的。例如，在大多数机器上，C 表达式 (3.14 + 1e20) - 1e20
求得的值会是 0.0，而 3.14 + (1e20 - 1e20) 求得的值会是 3.14。   

整数运算和浮点数运算会有不同的数学属性是因为他们处理数字表示有限性的方式不同——整数的表示
虽然只能编码一个相对较小的数值范围，但是这种表示时精确的；而浮点数虽然可以编码一个较大的
数值范围，但是这种表示只是近似的。   

## 2.1 信息存储

### 2.1.2 字数据大小

每台计算机都有一个 **字长**，指明指针数据的标称大小。因为虚拟地址是以这样的一个字来编码的，
所以决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为 w 位的机器
而言，虚拟地址的范围是 0 ~ 2<sup>w</sup>-1，程序最多访问 2<sup>w</sup> 个字节。    

我们将程序称为 “32位程序” 或 “64位程序” 时，区别在于该程序是如何编译的，而不是其运行的
机器类型。   

### 2.1.3 寻址和字节顺序

对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何
排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用
字节中最小的地址。     

排列表示一个对象的字节有两个通用的规则。考虑一个 w 位的整数，其位表示为 [x<sub>w-1</sub>,
w<sub>w-2</sub>, ..., x<sub>1</sub>, x<sub>0</sub>]。假设 w 是 8 的倍数，这些位就
能被分组成字节，某些机器在内存中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些
机器则按照从最高有效字节到最低有效字节的顺序存储。前一种规则称为 **小端法**，后一种规则
称为 **大端法**。    

假设变量 x 的类型为 int32, 位于地址 0x100 处，它的十六进制值为 0x01234567。地址范围
0x100~0x103 的字节顺序依赖于机器的类型：    

![big-endian-and-little-endian](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/big-little-endian.png)   

大多数 Intel 兼容机都只用小端模式。   

对于大多数应用程序员来说，其机器所使用的字节顺序是完全不可见的。无论为哪种类型的机器所
编译的程序都会得到同样的结果。不过有时候，字节顺序会成为问题。首先，是在不同类型的机器
之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者
反过来。     

### 2.1.4 表示字符串

C 语言中字符串被编码为一个以 null(acsii 码为0)字符结尾的字符数组。    

### 2.1.6 布尔代数简介

**布尔代数和布尔环**    

对于任意整数 w &gt; 0，长度为 w 的位向量上的布尔运算 |, & 和 ~ 形成了一个布尔代数。最
简单的情况是 w = 1 时，只有 2 个元素；但是对于更普遍的情况，有 2<sup>w</sup> 个长度为
w 的位向量。布尔代数和整数算术运算有很多相似之处。例如，乘法对加法的分配律 a * (b+c) =
(a * b) + (a * c)，而布尔运算 & 对 | 的分配律，a & (b | c) = (a & b) | (a & c)。
此外，布尔运算 | 对 & 也有分配律， a | (b & c) = (a | b) & (a | c)，但是对于整数我们
不能说 a + (b * c) = (a + b) * (a + c)。    

也就是 数据集合(2<sup>w</sup>个数) + 运算(|, &, ~) = 布尔代数。    

当考虑长度为 w 的位向量上的 ^, & 和 ~ 运算时，会得到一种不同的数学形式，我们称为布尔环。    

### 2.1.9 C 语言中的移位运算

右移运算 x &gt;&gt; k，一般而言，机器支持两种形式的右移：**逻辑右移** 和 **算术右移**。
逻辑右移在左端补 k 个 0，算术右移在左端补 k 个最高有效位的值。     

几乎所有的编译器/机器组合都对有符号数使用算术右移，另一方面，对于无符号数，右移必须是逻辑的。    

## 2.2 整数表示

### 2.2.2 无符号数的编码

假设有一个整数数据类型有 w 位，我们可以将位向量写成 x, 表示整个向量，或者写成[x<sub>w-1</sub>,
x<sub>w-2</sub>, ..., x<sub>0</sub>]，表示向量中的每一位。把 x 看做一个二进制表示的数，
就获得了 x 的无符号表示。B2U(Binary to Unsigned 的缩写，长度为 w)：   

![Binary-to-Unsigned](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/btu.png)   

函数 B2U 将一个长度为 w 的0,1 串映射到非负整数。因此一个采用 B2U 函数编码的无符号数的
取值范围是 0~2<sup>w</sup> - 1.一共包含 2<sup>w</sup> 个数。     

好像是这个意思，无符号是一种编码方式，但是我们这里使用的时候都是讨论的该编码方式编码的数字，
而二进制就是一个0，1串。所以 B2U，其实相当于给一个数的二进制表示，我们使用 B2U 函数将其
转换为一个无符号数的编码方式并得到其代表的数字。好像还是没说明白。。。。但是其实我们使用
的时候都是应该用的反向操作 U2B，即给一个数字，其为无符号编码，在内存中保存了其二进制格式的
数据。   

原理：无符号数编码的唯一性。函数 B2U 是一个双射。    

### 2.2.3 补码编码

对于很多应用，我们还希望表示负数值。最常见的有符号数的计算机表示方式就是 **补码**(two's-complenment)
形式。在这个定义中，将字的最高有效位解释为负权。我们用函数 B2T<sub>w</sub>(Binary to Two's-complement，
长度为w)来表示：    

![Binary-to-Two's-complement](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/btt.png)  

让我们来考虑一下 w 位补码所能表示的值的范围。它能表示的最小值是位向量[100....0]，其整数
值为 TMin<sub>w</sub> = -2<sub>w-1</sub>。而最大值是位向量 [01...1]，其整数值为
TMax<sub>w</sub> = 2<sup>w-1</sup> - 1.     

同无符号表示一样，在可表示的取值范围内的每个数字都有唯一一个的 w 位的补码编码。这就导出
了与无符号数相似的补码数原来：   

原理：补码编码的唯一性。函数 B2T 是一个双射。    

![important-numbers](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/important-numbers.png)  

关于这些数字，有几点值得注意。第一，补码的范围是不对称的：|TMin| = |TMax| + 1，也就是说，
TMin 没有与之对应的正数。正如我们将看到的，这导致了补码运算的某些特殊的属性，并且容易造成
程序中细微的错误。之所以有这样的不对称性，是因为一半的位模式（符号位设置为 1 的数）表示
负数，而另一半（符号位设置为0的数）表示非负数。因为 0 是非负数，也就意味着能表示的正数
比负数少一个。     

![ones-sign](https://raw.githubusercontent.com/temple-deng/markdown-images/master/computer-system/ones-sign.png)   

**重点：**请注意补码（Two's complement）和反码（Ones' complement）中撇号的位置是不同的。
术语补码来源于这样一个情况，对于非负数 x，我们用 2<sup>w</sup> - x（这里只有一个 2）来
计算 -x 的 w 位表示。术语反码来源于这样一个属性，我们用 [111...1] - x（这里有很多个 1）
来计算 -x 的反码表示。   

### 2.2.4 有符号数和无符号数之间的转换

C 语言允许在各种不同的数字数据类型之间做强制类型转换。将有符号数强制转换成无符号数，或者
反过来，会得到什么结果呢？

考虑如下代码：   

```c
short int v = -12345;
unsigned short uv = (unsigned short) v;
printf("v = %d, uv = %u\n", v, uv);
```   

在一台使用补码的机器上，上述代码会产生如下输出：    

v = -12345, uv = 53191    

-12345 的 16 位补码表示与 53191 的 16 位无符号表示是完全一样的。因此，强制类型转换的
结果保持位值不变，只是改变了解释这些位的方式。    

类似地，考虑如下的代码：    

```c
unsigned u = 4294967295u;   // UMax
int tu = (int) u;
printf("u = %u, tu = %d\n", u, tu);
```    

在一台使用补码的机器上，上述代码会产生如下输出：   

u = 4294967295, tu = -1    

对于大多数 C 语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值
可能会改变，但是位模式不变。让我们用更数学化的形式来描述这个规则。我们定义函数 U2B 和 T2B，
它们将数值映射为无符号数和补码形式的位表示。注意 U2B 和 T2B 都是双射。     

现在，将函数 T2U 定义为 T2U(x) = B2U(T2B(x))。这个函数的输入是一个 TMin~TMax 的数，结果
得到一个 0~UMax 的值。   

### 2.2.6 扩展一个数字的位表示

一个常见的运算是在不同字长的整数之间转换，同时又保持数值不变。当然，当目标数据类型太小以
至于不能表示想要的值时，这根本就是不可能的。然而，从一个较小的数据类型转换到一个较大的类型，
应该总是可能的。    

要将一个无符号数转换为一个更大的数据类型，我们只要简单地在表示的开头添加 0，这种运算被称为
**零扩展**。    

要将一个补码数字转换为一个更大的数据类型，可以执行一个 **符号扩展**，在表示中添加最高有效位的
值。     

### 2.2.7 截断数字

当将一个 w 位的数截断成一个 k 位数字时，我们会丢弃高 w-k 为。截断一个数字可能会改变他的
值——溢出的一种形式。   

无符号数的截断结果是：    

B2U<sub>k</sub>[x<sub>k-1</sub>, ..., x<sub>0</sub>] = B2U<sub>w</sub>([x<sub>w-1</sub>,
..., x<sub>0</sub>]) mod 2<sup>k<sup>.     

而补码数字的截断结果是：    

B2T<sub>k</sub>[x<sub>k-1</sub>, ..., x<sub>0</sub>] = U2T<sub>k</sub>(B2U<sub>w</sub>([x<sub>w-1</sub>,
..., x<sub>0</sub>]) mod 2<sup>k<sup>).        

## 2.3 整数运算

### 2.3.1 无符号加法

让我们为参数 x 和 y （无符号数）定义运算 +<sup>u</sup><sub>w</sub>，其中 0 &lt;= x, y &lt; 2<sup>w</sup>，
该操作是把整数和 x + y 截断为 w 位得到的结果，再把这个结果看做是一个无符号数。这可以被
视为一种形式的模运算，对 x+y 的位级表示，简单丢弃任何权重大于 2<sup>w-1<sup> 的位就可以
计算出和模 2<sup>w</sup>。     

考虑一个 4 位数字表示，x=9 和 y=12 的位表示分别为 1001 和 1100。它们的和是 21, 5 位的
表示为 10101。但是如果丢弃最高位，我们就得到 0101，也就是十进制的 5.这就和 21 mod 16 = 5
一致。    

原理：无符号数加法     

对满足  0 &lt;= x, y &lt; 2<sup>w</sup> 的 x 和 y 有：    

x +<sup>u</sup><sub>w</sub> y =  x + y,    x+y &lt; 2<sup>w</sup>  正常   
                              =  x + y - 2<sup>w</sup>,  2<sup>w</sup> &lt;= x + y &lt; 2<sup>w+1</sup>    溢出    

原理：检测无符号数加法中的溢出     

对在范围 0 &lt;= x, y &lt;= UMax<sub>w</sub> 中的 x 和 y，令 s = x +<sup>u</sup><sub>w</sub> y。
则对计算 s，当且仅当 s &lt; x（或者等价地 s &lt; y）时，发生了溢出。   

推导：检测无符号数加法中的溢出    

通过观察发现 x + y &gt;= x，因此如果 s 没有溢出，我们能肯定 s &gt;= x。另一个方面，
如果 s 确实溢出了，我们就有 s = x + y - 2<sup>w</sup>。 y &lt; 2<sup>w</sup>，
因此 s = x + (y - 2<sup>w</sup>) &lt; x。    

模数加法形成了一种数学结构，称为 **阿贝尔群**。也就是说，它是可交换和可结合的。它有一个
单位元 0，并且每个元素有一个加法逆元。考虑 w 位的无符号数的集合，执行加法运算+<sup>u</sup><sub>w</sub>.
对于每个值 x，必然有某个值 -<sup>u</sup><sub>w</sub>x 满足
-<sup>u</sup><sub>w</sub>x +<sup>u</sup><sub>w</sub> x = 0。该加法的逆操作可以表述
如下：    

原理：无符号数求反     

对满足 0 &lt;= x &lt; 2<sup>w</sup> 的任意 x，其 w 位的无符号逆元 -<sup>u</sup><sub>w</sub>x
由下式给出：    

-<sup>u</sup><sub>w</sub> = x    x=0   
                          = 2<sup>w</sup> - x,   x &gt; 0     


### 2.3.2 补码加法

给定在范围 -2<sup>w-1</sup> &lt; x, y &lt;= 2<sup>w-1</sup> - 1 之内的整数值 x 和 y，
它们的和就在范围 -2<sup>w</sup> &lt;= x + y &lt;= 2<sup>w</sup> - 1 之内，要想准确
表示，可能需要 w + 1 位。定义 x+<sup>t</sup><sub>w</sub> y 为整数和 x + y 被截断
w 位的结果，并将这个结果看作是补码数。    

原理：补码加法    

对满足 -2<sup>w-1</sup> &lt; x, y &lt;= 2<sup>w-1</sup> - 1 之内的整数值 x 和 y，有：    

x+<sup>t</sup><sub>w</sub> y = x + y - 2<sup>w</sup>,      2<sup>w-1</sup> &lt;= x + y    正溢出    
                             = x + y,         -2<sup>w-1</sup> &lt; x+y &lt; 2<sup>w-1</sup>  正常    
                             = x + y + 2<sup>w</sup>,   x + t &lt; -2<sup>w-1</sup>     负溢出     

原理：检测补码加法中的溢出     

对满足 TMin &lt;= x, y &lt;= TMax 的 x 和 y，令 s = x+<sup>t</sup><sub>w</sub> y。
当且仅当 x&gt;0, y &gt; 0，但 s &lt;= 0，计算 s 发生了正溢出。当且仅当 x &lt; 0, y &lt; 0,
但 s &gt;= 0 时，计算 s 发生了负溢出。     

其实说白了还是取模。    

### 2.3.4 无符号乘法

原理：无符号乘法    

对满足 0 &lt;= x, y &lt;= UMax 的 x 和 y 有：  x*<sup>t</sup><sub>w</sub> y = (x * y) mod 2<sup>w</sup>。     

### 2.3.5 补码乘法      

原理：补码乘法     

