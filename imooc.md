# 动态数组

+ 插入操作：O(n)
+ 移除操作：O(n)
+ 修改操作：如果已知待修改元素索引 O(1)，否则 O(n)
+ 查询操作，同修改    
+ addLast: O(1) 均摊复杂度
+ addFirst: O(n)
+ removeLast: O(1) 均摊复杂度
+ removeFirst: O(n)

假设 capacity = n, n+1 次 addLast，触发 resize，总共进行了 2n+1 次基本操作（n+1 次插入，
n 次的 resize 中的数据搬移），平均每次 addLast 操作，进行 2 次基本操作。   

因此，可以认为 addLast 和 removeLast 的均摊复杂度为 O(1)。   

复杂度震荡。   

# 栈

LIFO, Last In First Out。    

Stack&lt;E&gt;   

+ void push(E)  O(1) 均摊复杂度
+ E pop()    O(1)  均摊复杂度
+ E peek()   O(1)
+ int getSize()   O(1)
+ boolean isEmpty()  O(1)  

栈的底层有多种实现方式。上面的复杂度都是针对数组栈的底层实现。   

# 队列

FIFO, First In First Out。    

Queue&lt;E&gt;   

+ void enqueue(E)   O(1) 均摊复杂度
+ E dequeue()   O(n)
+ E getFront()  O(1)
+ int getSize()  O(1)
+ bool isEmpty() O(1)  

对于队列，我们只对队首的元素感兴趣。    

复杂度均为数组队列实现。   

与栈相同，队列的底层也有多种实现方式，所以我们把队列和栈都定义成了接口，而不是独立的结构。
我们只关注队列和栈应该实现哪些操作，而不关注其底层是数组还是链表实现的等等。   

# 循环队列

数组队列的问题是，每次出队的时间复杂度都是 O(n)。这是不可接受的。   

因此，我们可以换种想法，在队列中添加两个指针，front 和 tail，front 指向队首元素，
tail 指向队尾的下一个元素。那么这样我们在出队时，只是去移动 front 指针，而不是真的去
从数组首部移除元素，那么这个时间复杂度就又会下降到 O(1).    

![circular-queue](https://github.com/temple-deng/markdown-images/blob/master/other/circular-queue.png)    

这里我们在 tail 到达数组尾部的时候，重新指向队首部分已经出队的元素，同时假设 tail + 1 = front
时，队列为满。这样当 front=tail 的时候，就只有在队列为空的时候。    

说实话，这里取余的操作还是有点不理解。    

根据性能测试的结果，如果是单纯入队的操作，循环队列的性能并不比数组队列更好，甚至在测试时，
是一直要比数组队列差的，但是加入了出队操作后，循环队列的性能要明显优于数组队列。   

但是奇怪的是，在视频中的用例中，这种差距是上百倍的，但自己的电脑上也就个位数倍的差距。   

LoopQueue&lt;E&gt;   

+ void enqueue(E)   O(1)
+ E dequeue()   O(1)
+ E getFront()  O(1)
+ int getSize()  O(1)
+ bool isEmpty() O(1)  

# 链表

+ 数据存储在“节点”中
+ 优点：真正的动态，不需要处理固定容量的问题
+ 缺点：丧失了随机访问的能力    

在只保留头指针的情况下，很多链表的操作，都要针对在头结点和其他节点的操作进行分情况讨论，
究其原因是头结点前没有节点了，因此，我们可以手动添加一个虚拟节点，来简化我们的代码。   

+ 添加操作：
  - addFirst: O(1)
  - addLast: O(n)
  - insert: O(n)
+ 删除操作：
  - removeFirst: O(1)
  - removeLast: O(n)
  - remove: O(n)
+ 修改操作 set: O(n)
+ 查找操作：
  - get: O(n)
  - contains: O(n)

综合来看，链表的增删改查的操作的时间复杂度均为 O(n) 级别的，要比动态数组要查，但是需要
注意的是在表头进行的查找，删除和添加操作时间复杂度都是 O(1)，因此，链表适合于只对表头
进行操作的场景。    

在实际测试时，单就链表栈和数组栈来说，很难说链表栈一定比数组栈性能更好，因为数组栈我们只在达到
容量后，进行一次扩容操作，时间主要花费在多次的扩容操作上。但是链表呢，虽然无需扩容操作，但是
链表需要不断在内存中寻找可用的空间，存放新加入的 Node 节点，这一步也可能是很耗时的。   

# 链表队列

由于队列需要在一头增加元素，在另一头删除元素，因此单纯的使用我们之前的链表，性能并不是很好的。
这时候我们可以利用我们在循环队列中提到过的方法，添加一个 tail 指针（或者节点），来指向链表的
另一端。但由于在 tail 端删除元素仍要循环整个链表。因此我们可以颠倒一下队列的前后。    

使用 head 来充当队列的队首，由于在 head 处进行删除操作的复杂度是 O(1) 级别的，因此出队操作的
复杂度就是 O(1) 级别的。tail 指向另一端的最后一个节点（注意这里不是说像添加 dummyHead 一样，
添加一个 dummyTail 节点，这里 tail 就指向最后一个元素节点）。同时需要注意的是，由于我们不会
对链表中间的元素进行插入删除操作，所以就不需要使用 dummyHead 来统一我们函数的编写。    

因此，这里 head 指向第一个元素节点，充当队首，进行出队操作，tail 指向最后一个元素节点，充当
队尾，进行入队操作。    

# 二叉树

+ 二叉树具有唯一根节点
+ 二叉树每个节点最多有两个孩子
+ 没孩子的节点叫叶子节点
+ 二叉树具有天然递归结构
+ 满二叉树：除了叶子节点以外，其他节点都有两个孩子
+ 一个节点也是二叉树，甚至 null 也可以看成二叉树   

二分搜索树 Binary Search Tree    

+ 二分搜索树也是二叉树
+ 二分搜索树的每个节点的值：
  - 大于其左子树的所有节点的值
  - 小于其右子树的所有节点的值
+ 每一颗子树也是二分搜索树
+ 存储的元素必须有可比较性   

注意我们这里的定义，二分搜索树中不包含重复的元素，如果要包含重复的元素，需要修改上面的定义，
把小于或者大于改为小于等于或大于等于即可。    

## 插入和查询操作

利用递归结构，可以很方便的实现。    

## 遍历

1. **前序遍历**    

先访问节点，再访问节点的左右子树。   

```js
function traverse(node) {
  if (node == nill) {
    return;
  } else {
    // do sth
  }

  traverse(node.left);
  traverse(node.right);
}
```   

2. **中序遍历**    

先访问左子树，然后访问节点，再访问右子树。   

注意中序遍历的结果是一个排好序的结果。   

3. **后序遍历**    

先访问左右子树，再访问节点    


前中后三种遍历方式都是深度优先遍历的实例。    

而层序遍历是广度优先遍历的实例。    

## 删除问题

删除最小值：最小值一定是最左边的那个枝杈或者叶子节点，如果是叶子节点，那直接删除就好，但
如果是枝杈，那一定是有右子树，这种情况上直接把右子树整体提上来就好，即让右子树替换掉这个
枝杈。    

删除最大值：同理，最大值也类似。    

在删除任意值时，如果节点只有一边子树，这种情况是比较容易操作的，直接把子树上提即可。但是
如果有两边子树，那就比较复杂了，我们需要在左边子树中找到前驱，或者在右边子树中找到后继。
然后把这个节点先从原位置删除，然后再把这个节点替换掉要删除的节点，处理好子树的顺序即可。   

## 二分搜索树的复杂度分析

+ add, remove, contains 都是 O(h) 级别的，h是树的深度，O(h) = O(logn) logn 是一种
平均复杂度，最差的情况下 h = n，这是复杂度就是 O(n)

# 映射和集合

集合和映射的底层都可以使用链表或二分搜索树来实现，但需要注意的是使用二叉搜索树的实现，
要求键名必须是可排序的。   

# 堆和优先队列

优先队列的时间复杂度：   

+ 普通线性结构的底层实现：
  - 入队：O(1)
  - 出队：O(n)
+ 顺序线性结构的底层实现：
  - 入队：O(n)
  - 出队：O(1)
+ 堆
  - 入队：O(logn)
  - 出队：O(logn)

## 堆

二叉堆：   

+ 完全二叉树：不一定是满二叉树，但是其缺少的部分一定在树的右下方。    
+ 堆中某个节点的值总是不大于其父节点的值。这种情况的堆称为最大堆。相应的，我们可以定义最小堆。   

@TODO


如果索引从 0 开始，则 parent = (i-1)/2, leftChild = 2i + 1, rightChild = 2i + 2。    

我们可以使用动态数组来实现一个堆。   

+ **Sift Up**：添加元素的时候直接添加到数组的末尾，由于此次添加可能会打破堆的排列原则，
所以我们可能有必要将这个元素进行上浮，找到一个它适合的位置或者到堆顶，这个操作叫做 Sift Up
+ **Sift Down**：同理在删除最大的元素的时候，我们并不是进行左右两个子树的重组，而是首先
将数组尾部的那个元素提到堆顶，然后将其慢慢下沉，这个操作叫 Sift Down.怎么沉呢，具体就是
不断地找元素本身，元素的左右两个子节点中最大的那个，然后两个调换位置，直到满足最大堆的定义位置
或者到了叶子节点。   

复杂度方面:   

+ add 和 removeMax 的时间复杂度都是 O(logn)，而且由于堆是一个完全二叉树，所以其时间
复杂度是不会退化成 O(n) 级别的。   
+ replace 和 heapify
  - replace: 是指将最大元素取出，并插入一个新的元素值，一种简单的解法就是直接 removeMax
  然后再 add 一下，这样的话时间复杂度就是 O(2logn)，另一种思路是，我们直接用新添加的元素
  替换掉堆顶元素，然后执行 sift down，这样复杂度就是 O(logn)
  - heapify: 是指给一个乱序的数组，然后对其进行处理，使其满足一个最大堆，解法是从最后一个
  非叶子节点开始，知道堆顶节点，逐个进行 Sift Down 操作，复杂度是 O(n)

# 线段树（区间树）Segment Tree


&nbsp; | 使用数组实现 | 使用线段树
---------|----------|---------
 染色操作（更新区间） | O(n) | O(logn)
 查询操作（查询区间） | O(n) | O(logn)    

@TODO    

+ 线段树是平衡二叉树
+ 如果区间有 n 个元素，数组表示需要有 4n 的空间

# Trie

查询每个条目的时间复杂度和字典中一共有多少条目无关。而跟字符串的长度有关，具体来说，字符串长度
为 l，则时间复杂度就是 O(l)。    

每个节点有 26 个指向下个节点的指针。考虑到不同的语言和不同情景，可能 26 个是多余或者不够的。   

因此通常我们经常让每个节点有若干个指向下个节点的指针。并且让这些指针保存到一个 map 里，将
map 保存在 trie 中。   

```java
class Node {
  char c;
  Map<char, *Node> next;
}
```  

```java
class Node {
  boolean isWord;
  Map<char, *Node> next;
}