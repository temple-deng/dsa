# 动态数组

+ 插入操作：O(n)
+ 移除操作：O(n)
+ 修改操作：如果已知待修改元素索引 O(1)，否则 O(n)
+ 查询操作，同修改    
+ addLast: O(1) 均摊复杂度
+ addFirst: O(n)
+ removeLast: O(1) 均摊复杂度
+ removeFirst: O(n)

假设 capacity = n, n+1 次 addLast，触发 resize，总共进行了 2n+1 次基本操作（n+1 次插入，
n 次的 resize 中的数据搬移），平均每次 addLast 操作，进行 2 次基本操作。   

因此，可以认为 addLast 和 removeLast 的均摊复杂度为 O(1)。   

复杂度震荡。   

# 栈

LIFO, Last In First Out。    

Stack&lt;E&gt;   

+ void push(E)  O(1) 均摊复杂度
+ E pop()    O(1)  均摊复杂度
+ E peek()   O(1)
+ int getSize()   O(1)
+ boolean isEmpty()  O(1)  

栈的底层有多种实现方式。上面的复杂度都是针对数组栈的底层实现。   

# 队列

FIFO, First In First Out。    

Queue&lt;E&gt;   

+ void enqueue(E)   O(1) 均摊复杂度
+ E dequeue()   O(n)
+ E getFront()  O(1)
+ int getSize()  O(1)
+ bool isEmpty() O(1)  

对于队列，我们只对队首的元素感兴趣。    

复杂度均为数组队列实现。   

与栈相同，队列的底层也有多种实现方式，所以我们把队列和栈都定义成了接口，而不是独立的结构。
我们只关注队列和栈应该实现哪些操作，而不关注其底层是数组还是链表实现的等等。   

# 循环队列

数组队列的问题是，每次出队的时间复杂度都是 O(n)。这是不可接受的。   

因此，我们可以换种想法，在队列中添加两个指针，front 和 tail，front 指向队首元素，
tail 指向队尾的下一个元素。那么这样我们在出队时，只是去移动 front 指针，而不是真的去
从数组首部移除元素，那么这个时间复杂度就又会下降到 O(1).    

![circular-queue](https://github.com/temple-deng/markdown-images/blob/master/other/circular-queue.png)    

这里我们在 tail 到达数组尾部的时候，重新指向队首部分已经出队的元素，同时假设 tail + 1 = front
时，队列为满。这样当 front=tail 的时候，就只有在队列为空的时候。    

说实话，这里取余的操作还是有点不理解。    

根据性能测试的结果，如果是单纯入队的操作，循环队列的性能并不比数组队列更好，甚至在测试时，
是一直要比数组队列差的，但是加入了出队操作后，循环队列的性能要明显优于数组队列。   

但是奇怪的是，在视频中的用例中，这种差距是上百倍的，但自己的电脑上也就个位数倍的差距。   

LoopQueue&lt;E&gt;   

+ void enqueue(E)   O(1)
+ E dequeue()   O(1)
+ E getFront()  O(1)
+ int getSize()  O(1)
+ bool isEmpty() O(1)  

# 链表

+ 数据存储在“节点”中
+ 优点：真正的动态，不需要处理固定容量的问题
+ 缺点：丧失了随机访问的能力    

在只保留头指针的情况下，很多链表的操作，都要针对在头结点和其他节点的操作进行分情况讨论，
究其原因是头结点前没有节点了，因此，我们可以手动添加一个虚拟节点，来简化我们的代码。   

+ 添加操作：
  - addFirst: O(1)
  - addLast: O(n)
  - insert: O(n)
+ 删除操作：
  - removeFirst: O(1)
  - removeLast: O(n)
  - remove: O(n)
+ 修改操作 set: O(n)
+ 查找操作：
  - get: O(n)
  - contains: O(n)

综合来看，链表的增删改查的操作的时间复杂度均为 O(n) 级别的，要比动态数组要查，但是需要
注意的是在表头进行的查找，删除和添加操作时间复杂度都是 O(1)，因此，链表适合于只对表头
进行操作的场景。    

在实际测试时，单就链表栈和数组栈来说，很难说链表栈一定比数组栈性能更好，因为数组栈我们只在达到
容量后，进行一次扩容操作，时间主要花费在多次的扩容操作上。但是链表呢，虽然无需扩容操作，但是
链表需要不断在内存中寻找可用的空间，存放新加入的 Node 节点，这一步也可能是很耗时的。   

# 链表队列

由于队列需要在一头增加元素，在另一头删除元素，因此单纯的使用我们之前的链表，性能并不是很好的。
这时候我们可以利用我们在循环队列中提到过的方法，添加一个 tail 指针（或者节点），来指向链表的
另一端。但由于在 tail 端删除元素仍要循环整个链表。因此我们可以颠倒一下队列的前后。    

使用 head 来充当队列的队首，由于在 head 处进行删除操作的复杂度是 O(1) 级别的，因此出队操作的
复杂度就是 O(1) 级别的。tail 指向另一端的最后一个节点（注意这里不是说像添加 dummyHead 一样，
添加一个 dummyTail 节点，这里 tail 就指向最后一个元素节点）。同时需要注意的是，由于我们不会
对链表中间的元素进行插入删除操作，所以就不需要使用 dummyHead 来统一我们函数的编写。    

因此，这里 head 指向第一个元素节点，充当队首，进行出队操作，tail 指向最后一个元素节点，充当
队尾，进行入队操作。    

# 二叉树

+ 二叉树具有唯一根节点
+ 二叉树每个节点最多有两个孩子
+ 没孩子的节点叫叶子节点
+ 二叉树具有天然递归结构
+ 满二叉树：除了叶子节点以外，其他节点都有两个孩子
+ 一个节点也是二叉树，甚至 null 也可以看成二叉树   

二分搜索树 Binary Search Tree    

+ 二分搜索树也是二叉树
+ 二分搜索树的每个节点的值：
  - 大于其左子树的所有节点的值
  - 小于其右子树的所有节点的值
+ 每一颗子树也是二分搜索树
+ 存储的元素必须有可比较性   

注意我们这里的定义，二分搜索树中不包含重复的元素，如果要包含重复的元素，需要修改上面的定义，
把小于或者大于改为小于等于或大于等于即可。    

## 插入和查询操作

利用递归结构，可以很方便的实现。    

## 遍历

1. **前序遍历**    

先访问节点，再访问节点的左右子树。   

```js
function traverse(node) {
  if (node == nill) {
    return;
  } else {
    // do sth
  }

  traverse(node.left);
  traverse(node.right);
}
```   

2. **中序遍历**    

先访问左子树，然后访问节点，再访问右子树。   

注意中序遍历的结果是一个排好序的结果。   

3. **后序遍历**    

先访问左右子树，再访问节点    


前中后三种遍历方式都是深度优先遍历的实例。    

而层序遍历是广度优先遍历的实例。    

## 删除问题

删除最小值：最小值一定是最左边的那个枝杈或者叶子节点，如果是叶子节点，那直接删除就好，但
如果是枝杈，那一定是有右子树，这种情况上直接把右子树整体提上来就好，即让右子树替换掉这个
枝杈。    

删除最大值：同理，最大值也类似。    

在删除任意值时，如果节点只有一边子树，这种情况是比较容易操作的，直接把子树上提即可。但是
如果有两边子树，那就比较复杂了，我们需要在左边子树中找到前驱，或者在右边子树中找到后继。
然后把这个节点先从原位置删除，然后再把这个节点替换掉要删除的节点，处理好子树的顺序即可。   

## 二分搜索树的复杂度分析

+ add, remove, contains 都是 O(h) 级别的，h是树的深度，O(h) = O(logn) logn 是一种
平均复杂度，最差的情况下 h = n，这是复杂度就是 O(n)

# 映射和集合

集合和映射的底层都可以使用链表或二分搜索树来实现，但需要注意的是使用二叉搜索树的实现，
要求键名必须是可排序的。   

# 堆和优先队列

优先队列的时间复杂度：   

+ 普通线性结构的底层实现：
  - 入队：O(1)
  - 出队：O(n)
+ 顺序线性结构的底层实现：
  - 入队：O(n)
  - 出队：O(1)
+ 堆
  - 入队：O(logn)
  - 出队：O(logn)

## 堆

二叉堆：   

+ 完全二叉树：不一定是满二叉树，但是其缺少的部分一定在树的右下方。    
+ 堆中某个节点的值总是不大于其父节点的值。这种情况的堆称为最大堆。相应的，我们可以定义最小堆。   

@TODO


如果索引从 0 开始，则 parent = (i-1)/2, leftChild = 2i + 1, rightChild = 2i + 2。    

我们可以使用动态数组来实现一个堆。   

+ **Sift Up**：添加元素的时候直接添加到数组的末尾，由于此次添加可能会打破堆的排列原则，
所以我们可能有必要将这个元素进行上浮，找到一个它适合的位置或者到堆顶，这个操作叫做 Sift Up
+ **Sift Down**：同理在删除最大的元素的时候，我们并不是进行左右两个子树的重组，而是首先
将数组尾部的那个元素提到堆顶，然后将其慢慢下沉，这个操作叫 Sift Down.怎么沉呢，具体就是
不断地找元素本身，元素的左右两个子节点中最大的那个，然后两个调换位置，直到满足最大堆的定义位置
或者到了叶子节点。   

复杂度方面:   

+ add 和 removeMax 的时间复杂度都是 O(logn)，而且由于堆是一个完全二叉树，所以其时间
复杂度是不会退化成 O(n) 级别的。   
+ replace 和 heapify
  - replace: 是指将最大元素取出，并插入一个新的元素值，一种简单的解法就是直接 removeMax
  然后再 add 一下，这样的话时间复杂度就是 O(2logn)，另一种思路是，我们直接用新添加的元素
  替换掉堆顶元素，然后执行 sift down，这样复杂度就是 O(logn)
  - heapify: 是指给一个乱序的数组，然后对其进行处理，使其满足一个最大堆，解法是从最后一个
  非叶子节点开始，知道堆顶节点，逐个进行 Sift Down 操作，复杂度是 O(n)

# 线段树（区间树）Segment Tree


&nbsp; | 使用数组实现 | 使用线段树
---------|----------|---------
 染色操作（更新区间） | O(n) | O(logn)
 查询操作（查询区间） | O(n) | O(logn)    

@TODO    

+ 线段树是平衡二叉树
+ 如果区间有 n 个元素，数组表示需要有 4n 的空间

# Trie

查询每个条目的时间复杂度和字典中一共有多少条目无关。而跟字符串的长度有关，具体来说，字符串长度
为 l，则时间复杂度就是 O(l)。    

每个节点有 26 个指向下个节点的指针。考虑到不同的语言和不同情景，可能 26 个是多余或者不够的。   

因此通常我们经常让每个节点有若干个指向下个节点的指针。并且让这些指针保存到一个 map 里，将
map 保存在 trie 中。   

```java
class Node {
  char c;
  Map<char, *Node> next;
}
```  

```java
class Node {
  boolean isWord;
  Map<char, *Node> next;
}
```   

# 并查集 Union Find

并查集可以非常迅速地判断网络中节点间的连接状态。   

对于一组数据，主要支持两个动作：   

+ union(p, q)
+ isConnected(p, q)    

并查集也可以有不同的底部实现。   

并查集的基本数据表示：   

```
0  1  2  3  4  5  6  7  8  9 
-----------------------------
0  0  0  0  0  1  1  1  1  1
```   

上面的数字代表并查集中元素的一个编号。下面的数字代表元素所属的集合的 ID。例如上面
0~4 编号元素属于 ID 为 0 的集合，另外的元素属于一个集合。    

@TODO   

上图是 Quick Union 实现的一种简要表示

# AVL 树

+ 平衡二叉树：对于任意一个节点，左子树和右子树的高度差不能超过 1
+ 什么时候要进行维护平衡的操作呢，显然，我们是在插入一个节点后，可能会破坏了二叉树的平衡限制，
因此，我们的维护操作应该放到插入节点后。   

@TODO 右旋转

# 红黑树

+ 红黑树依然是一颗二分搜索树
+ 每个节点或者是红色，或者是黑色的
+ 根节点是黑色的
+ 每一个叶子节点（最后的空节点）是黑色的，要注意这里对叶子节点的定义
+ 如果一个节点是红色的，那么他的孩子节点都是黑色的
+ 从任意一个节点到叶子节点，经过的黑色节点是一样的   

## 2-3 树

+ 2-3 树满足二分搜索树的基本性质
+ 但是 2-3 树不是一颗二叉树，因为 2-3 树有两种节点，一种节点可以存放一个元素，一种节点可以存放两个元素    
+ 每个节点或者有两个孩子，或者有三个孩子，有两个孩子的节点包含一个值，叫做 2 节点，有 3 个
孩子的包含两个值，叫做 3 节点
+ 上面所谓的满足二分搜索树的性质是指，在两个孩子的情况下，与二分搜索树一致，在三个孩子的情况，
如下所示，小于 b 的在左子树，大于 b 小于 c 的在中子树，大于 c 的在右子树。
+ 2-3 树是一颗绝对平衡树

```
      a               b  c
    /   \           /   |   \
```       

如何维护绝对平衡性：   

+ 首先，新节点绝对不会添加到空的位置   

例如首先我们有一颗以 42 为根的 2-3 树，并且这也是树中唯一的节点，现在要插入一个值为 37
的节点，按二分搜索树的定义，我们理论上应该添加到左子树中，但目前左子树是空，因此不能插入。
此时这个 37 应该融合到我们安装二分搜索树寻找添加位置过程中寻找到的最后一个叶子节点，因此
这里就是和 节点 42 融合。   

`37 | 42`    

假设现在又要添加一个 12 的节点，这时仍然先进行融合：   

`12 | 37 | 42`    

这时，2-3 进行分裂：   

```
    37
  /    \
 12    42
```   

假设这时又要添加一个值为 18 的节点，按照二分搜索树的规律，我们应该添加到 12 的右子树中，
这里值为 12 的节点就是我们最后找到的叶子节点，此时 18 应与 12 融合：   

```
     37
   /    \
12 | 18  42
```    

然后再添加一个 6，也是与值为 12 的节点进行融合，这时又要进行分裂，但这里分裂就不像上面
那么简单了，因为按照上面那样拆解，就不是一颗绝对平衡树了。    

如果一个叶子节点已经是一个 3 节点了，添加一个节点变成了 4 节点，这时必须进行分裂，我们
首先还是将 4 节点拆分成一个 3 个 2 节点的子树，之后，新的根节点，在这里就是值为 12
的节点，向上与父节点进行融合，这里父节点 37 是一个 2 节点，所以是可以直接融合的。融合
后，12 的左子树变成了融合节点左子树，12 的右子树变成了融合节点的中子树：    

```
        37                        37                               12 | 37
     /      \     分裂          /     \      12 向上融合            /   |    \
6 | 12 | 18  42   ===>        12      42    ===========>         6    18    42
                            /    \
                           6     18
```    

然后再添加一个 11 的节点，变成这样：    

```
        12 | 37
    /      |     \
  6 | 11   18     42
```    

这时又要添加一个值为 5 的节点，这里我们按照上面的方法，进行 3 节点融合为 4 节点，4 节点
分裂，根节点向上融合，但这里根节点 6 的父节点已经是一个 3 节点，融合后又成了一个 4 节点，
所以还要进行分裂。      

```
        12 | 37                         6 | 12 | 37 
      /    |    \     6向上融合         /   |    |    \     再次分裂
     6     18   42    ========>       5   11   18    42    ======>
   /  \
  5   11


                12
              /    \
             6     37
           /  \    /  \
          5   11  18   42
```     

## 红黑树与 2-3 树的等价性

@TODO 红黑树与 2-3 树

+ 所有的红色节点都是左倾斜的。    
+ 3 节点转换为一红一黑的两个 2 节点，其中 3 节点的中字树有两种选择，红节点的右子树或者
黑节点的左子树，但是由于黑节点的左子树已经确定了是红节点为根的子树，因此其只能安排到红节点
的右子树
