# 第 1 章 开篇

## 1.1 准备的问题描述

+ 输入：一个最多包含 n 的正整数的文件，每个数都小于 n，其中 n = 10^7。如果在输入文件中
有任何整数重复出现就是致命错误。
+ 输出：按升序排列的输入整数的列表。
+ 约束：最多有 1 MB 的内存空间可用，有充足的磁盘存储空间可用。    

## 1.2 程序设计

显而易见的方法是以一般的基于磁盘的归并排序程序为起点。另一种解决方案给多地利用了该排序问题
的特殊性。    

如果每个号码都使用 7 个字节来存储（话说为什么要用这么多字节），那么在可用的 1 MB存储空间
大约可以存 143 000 个号码（注，这里以 1000 为进制了）。如果每个号码都可以用 32 位整数
来表示的话，在 1 MB 的存储空间就可以存储 250 000 个号码。因此，可以使用遍历输入文件 40
趟来完成排序。在第一趟遍历中，将 0 至 249 999 之间的任何整数都读入内存，并对这些数进行
排序，然后写到输出文件中。第二趟遍历排序 250 000 至 499 999 之间的整数，依次类推。    

对内存中的排序来说，快排会相当高效。代价是要读取输入文件 40 次。    

归并排序读取输入文件一次，然后在工作文件的帮助下完成排序并写入输出文件一次。工作文件需要
多次读写。    

但是我们是否可以将两者结合一下，使得只用读写输入和输出文件一次，且不用额外的工作文件。这时候
就要求我们必须在 1MB 的内存空间中装下文件中所有的数据。于是问题就归结为是否能够用大约 800 万
个可用位来表示最多 1000 万个互异的整数。    

## 1.4 实现概要

由是观之，应该用位图或位向量表示集合。可用一个 20 为长字符串来表示一个所有元素都小于 20 的
简单的非负整数集合。例如，可以用如下字符串来表示集合 {1, 2, 3, 5, 8, 13};    

`0 1 1 1 0 1 0 0 1 0 0 0 0 1 0 0 0 0 0 0`    

代表集合中数值的位都置为 1，其他所有的位都置为 0.    

在我们的实际问题中，每个 7 位十进制整数都表示一个小于 1000 万的整数。我们使用一个具有
1000 万个位的字符串来表示这个文件，其中，当且仅当整数 i 在文件中存在时，第 i 位为 1.
（那个程序员后来找到了 200 万个稀疏位）这种表示利用了该问题的三个在排序问题中不常见的
属性：输入数据限制在相对较小的范围内；数据没有重复；而且对于每条记录而言，除了单一整数
外，没有任何其他关联数据。      

若给定表示文件中整数集合的位图数据结构，则可以分三个自然阶段来编写程序。第一阶段将所有
的位都置为 0，从而将集合初始化为空。第二阶段通过读入文件中的每个整数来建立集合，将每个
对应的位都置为 1.第三阶段检验每一位，如果该位为 1，就输出对应的整数，由此产生有序的输出文件。    

# 第 2 章 啊哈！算法

## 2.1 问题

+ 将一个 n 元一维向量向左旋转 i 个位置。例如，当 n = 8, i = 3时，向量 abcdefgh
旋转为 defghabc。     
+ 给定一个英语字典，找出其中的所有变位词集合。例如，pots, stop, tops 互为变位词，因为
每一个单词都可以通过改变其他单词中字母的顺序来得到。   

## 2.2 基本操作的威力

我们将问题看做是把数组 ab 转换成数组 ba，同时假定我们拥有一个函数可以把数组中特定部分的
元素求逆。从 ab 开始，首先对 a 求逆，再对 b 求逆，最后整体求逆，结果恰好就是 ba.    

```
reverse(0, i-1)
reverse(i, n-1)
reverse(0, n-1)
```    

## 2.3 排序

可以使用映射来完成这个问题把，映射的键是所有可能非变位词的单词的字母表排序的结果，值就是
变位词的集合。然后针对每个单词，首先把单词排序后检查是否在 map 中，如果在就填入集合中，
如果不在，就以结果为键新建一个集合并放入单词。     

