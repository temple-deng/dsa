# 第 1 章 绪论

## 1.3 重要的问题类型

+ 排序
+ 查找
+ 字符串处理
+ 图问题
+ 组合问题
+ 几何问题
+ 数值问题    

### 1.3.1 排序

排序使我们更容易求解和列表相关的问题。其中最重要的是查找问题：这就是为什么字典、电话簿和班级名册
都是拍好序的。同样原因，在很多其他领域的重要算法（例如几何算法和数据压缩）中，排序也被作为一个
辅助步骤。贪婪算法也要求有序的输入。    

### 1.3.2 查找

有很多查找算法可供选择，其中既包括直截了当的顺序搜索，也包括效率极高但应用受限的这班查找，还有
那些将原集合用另一种形式表示以方便查找的算法。   

### 1.3.3 图算法

基本的图算法包括图的遍历算法（如何能一次访问到网络中的所有节点）、最短路线算法（两个城市之间
的最佳路线是哪条？）以及有向图的拓扑排序（一系列课程的预备课程是相互一致的，还是自相矛盾的？）。    

有一些图问题在计算上是非常困难的。其中最广为人知的恐怕要数旅行商问题和图填色问题了。**旅行商问题**
(traveling salesman problem, TSP) 就是要找出访问 n 个城市的最短路径，并且保证每个城市
只访问一次。**图填色问题** 就是要用最少种类的颜色为图中的顶点着色，并保证任何两个邻接顶点
的颜色都不同。这个问题源于若干应用，例如安排事务进度：如果用以边相连的顶点代表事务，当且
仅当独立事务无法排定同时发生时，图填色问题的解才能生成一张最优的日程表。   

### 1.3.4 组合问题

从更抽象的角度来看，旅行商问题和图着色问题都是 **组合问题** 的特例。有一些问题要求寻找一个
组合对象，例如一个排列、一个组合或者一个子集，这些对象能够满足特定的条件并具有我们想要的
特性，如价值最大化或成本最小化。    

一般说来，无论从理论角度还是实践角度来看，组合问题都是计算领域中最难的问题。这时出于以下原因。
第一，通常，随着问题规模的增大，组合对象的数量增长极快，即使是中等规模的实例，其组合的规模也
会达到不可思议的数量级。第二，还没有一种已知算法能在可接受的时间内，精确地解决绝大多数这类
问题。而且，大多数计算机科学家认为这样的算法是不存在的。但这个猜想即没被证实，也没被证伪。    

有些组合问题用高效的算法求解，但我们应该把它们当作幸运的例外。这些例外中就包含前面提到的
最短路径算法。    

## 1.4 基本数据结构

### 1.4.1 图

几个概念：   

+ 有向和无向
+ 有权和无权
+ 完全图
+ 邻接表
+ 邻接矩阵
+ 路径
+ 简单路径
+ 连通性和连通分量
+ 邻接
+ 自环
+ 平行边    

**状态空间树**(state-space tree)，它强调了两种重要的算法设计技术：**回溯** 和 **分支界限**。   

顶点 v 的深度是从根到 v 的简单路径的长度。树的高度是从根到叶节点的最长简单路径的长度。    

# 第 2 章 算法效率分析

## 2.3 非递归算法的数学分析

分析非递归算法效率的通用方案：   

1. 决定用哪个（哪些）参数表示输入规模
2. 找出算法的基本操作（作为一个规律，它总是位于算法的最内层循环中）
3. 检查基本操作的执行次数是否只依赖于输入规模。如果它还依赖与一些其他的特性，则最差效率、平均
效率以及最优效率需要分别研究
4. 建立一个算法基本操作执行次数的求和表达式
5. 利用求和运算的标准公式和法则来建立一个操作次数的闭合公式，或者至少确定它的增长次数   

@TODO 求和公式

## 2.4 递归算法的数学分析

分析递归算法时间效率的通用方案：   

1. 决定用哪个（哪些）参数作为输入规模的度量标准
2. 找出算法的基本操作
3. 检查一下，对于相同规模的不同输入，基本操作的执行次数是否可能不同。如果有这种可能，则必须
对最差效率、平均效率以及最优效率做单独研究
4. 对于算法基本操作的执行次数，建立一个递归关系以及相应的初始条件
5. 解这个递归式，或者至少确定它的解的增长次数    

@TODO 递推关系   

## 2.5 计算第 n 个斐波那契数

斐波那契数列可以用一个简单的递推式和两个初始条件来定义：   

当 n &gt; 1 时，F(n) = F(n-1) + F(n-2)    
    F(0) = 0，  F(1) = 1    

首先，先给出一个求解第 n 个斐波那契数的明确的公式。如果试着应用反向替换法来接递归公式。我们将
无法得到一个容易识别的模式。但我们可以改用另外一个定理。这个定理描述了如何求解
**带常系数的齐次二阶线性递推式**。    

ax(n) + bx(n-1) + cx(n-2) = 0    

其实,a, b, c 都是固定的实数，称为该递推式的系数，x(n) 是一个待解的未知数列的一般项。将该定理
应用到一个具有给定初始条件的递推关系中，我们将获得下列公式：    

@TODO

# 第 3 章 蛮力法

**蛮力法**(brute force) 是一种简单直接地解决问题的方法，常常直接基于问题的描述和所涉及的
概念定义。    

虽然巧妙和高效的算法很少来自于蛮力法，但我们不应该忽略它作为一种重要的算法设计策略的地位。第一，
和其他某些策略不同，我们可以应用蛮力法解决广阔领域的各种问题。实际上，它可能是唯一一种几乎
什么问题都能解决的一般性方法。第二，对于一些重要的问题来说，蛮力法可以产生一些合理的算法，
它们多少具备一些实用价值，而且不必限制实例的规模。第三，如果要解决的问题实例不多，而且蛮力法
可以用一种能够接受的速度对实例求解，那么，设计一个更高效算法所花费的代价很可能是不值得的。    

## 3.1 选择排序和冒泡排序

选择排序略了。   

冒泡排序比较表中的相邻元素，如果它们是逆序的话就交换它们的位置。重复多次以后，最终，最大的元素
就“沉到”列表的最后一个位置。第二遍操作将第二大的元素沉下去。这样一直做，直到 n - 1 遍以后，
该列表就排好序了。    

```go
func BubbleSort(arr []int) {
	length := len(arr)

	for i := 0; i < length-1; i++ {
		for j := 0; j < length-1-i; j++ {
			if arr[j] > arr[j+1] {
				swap(arr, j, j+1)
			}
		}
	}
}
```   

这里仔细分析一下两层循环的临界条件，外层循环每迭代一次，都有一个数下沉到最后，那么理论上一共
需要迭代 n 次，但是介于只剩一个数的时候其实就已经不用迭代了，因此实际上只用迭代 n-1 次，因此
i 的最大可取值为 n-2。内层循环，每次迭代的范围是从 0 到当前未排序的数组的倒数第二个元素，即
n-2-i。    

## 3.2 顺序查找和蛮力字符串匹配

顺序查找略。   

蛮力字符串匹配：   

```js
function BruteForceStringMatch(text, pattern) {
  const tLen = text.length;
  const pLen = pattern.length;

  // 注意这里临界值
  for (let i = 0; i <= tLen-pLen; i++) {
    for (let j = 0; j < pLen; j++) {
      if (text[i+j] !== pattern[j]) {
        break;
      }
    }
    if (j === pLen) {
      return i;
    }
  }
  return -1
}
```   

在移动模式之前，算法可能要做足 m 次比较（m 是 pattern 的长度），而 n-m+1 次尝试的每一次
都可能会遇到这种情况。因此在最坏的情况下，该算法属于 O(mn)。然而，对于在自然语言文本中
查找词的典型问题，我们可以认为大多数移动都发生在很少的几次比较之后。所以，该算法的平均效率
应该比最差效率好的多。事实上也是这样，在查找随机文本时，它能够显示出线性的效率，即 O(n)。    

## 3.4 穷举查找

许多重要的问题要求在一个复杂度随实例规模指数增长的域中，查找一个具有特定属性的元素。无论是
明智还是暗指，一般来说，这种问题往往涉及组合对象，例如排列、组合以及一个给定集合的子集。许多
这样的问题都是最优问题：它们要求找到一个元素，能使某些期望的特性最大化或最小化，例如路径的
长度或分配的成本。    

对于组合问题来说，**穷举查找** 是一种简单的蛮力方法。它要求生成问题域中的每一个元素，选出
其中满足问题约束的元素，然后再找出一个期望元素。    

### 3.4.1 旅行商问题

这个问题要求找出一条 n 个给定的城市间的最短路径，使我们在回到出发的城市之前，对每个城市都
只访问一次。这个问题可以很方便地用加权图来建模，也就是说，用图的顶点代表城市，用边的权重
表示城市间的距离。这样该问题就可以表述为求一个图的最短 **哈密顿回路** 问题。我们把哈密顿
回路定义为一个对图的每个顶点都只穿越一次的回路。    

很容易看出，哈密顿回路可以定义为 n+1 个相邻顶点的一个序列，其中，第一个和最后一个顶点是
相同的，而其他 n-1 个顶点都是互不相同的。因此，可以通过生成 n-1 个中间城市的组合来得到
所有的旅行线路，计算这些线路的长度，然后求得最短的线路。   

### 3.4.2 背包问题

给定 n 个重量为 w1, w2, ..., wn，价值为 v1, v2, ..., vn 的物品和一个承重为 W 的背包，
求这些物品中一个最有价值的子集，并且要能够装到背包中。    

在这个问题中，穷举查找需要考虑给定的 n 个物品集合的所有子集，为了找出可行的子集，要计算出每个
子集的总重量，然后在它们中间找到价值最大的子集。因为一个 n 元素集合的子集数量是 2^n，所以
不论生成独立子集的效率有多高，穷举查找都会导致一个 Ω(2^n) 的算法。    

因此，不论对旅行商问题还是背包问题，穷举查找型算法对于任何输入都是非常低效率的。实际上，这两个
问题就是所谓的 **NP困难问题** 中最著名的例子。对于 NP 困难问题，目前没有已知的效率可以
用多项式来表示的算法。而且，大多数计算机科学家相信，这样的算法是不存在的。一些更复杂的方法
—— 回溯法和分支界限法使我们可以在优于指数级的效率下解决该问题的部分实例。    

## 3.5 深度优先查找和广度优先查找

在深度优先查找遍历的时候构造一个所谓的深度优先查找森林也是非常有用的。遍历的初始节点可以作为
这样

# 第 4 章 减治法

**减治法** 技术利用了一个问题给定实例的解和同样问题较小实例的解之间的某种关系。一旦建立了
这种关系，我们即可以从顶至下，也可以从底至上地运用该关系。虽然自顶向下会自然导致出递归算法，
但从本章的例子可以看出，最终还是非递归实现较好。自底向上版本往往是迭代实现的，从求解问题的一个
较小实例开始，该方法有时也称为 **增量法**。   

减治法有 3 种主要的变化形式：   

+ 减去一个常量
+ 减去一个常量因子
+ 减去的规模是可变的    

在 **减常量** 变化形式中，每次算法迭代总是从实例中减去一个相同的常量。一般来说，这个常量
等于 1。    

@TODO 图

作为一个例子，考虑指数问题 a<sup>n</sup> 的值，其中 a != 0, n 为非负整数，很明显，规模
为 n 的实例和规模为 n-1 的实例的关系，可由公式 a<sup>n</sup> = a<sup>n-1</sup> * a
来描述。所以函数 f(n) = a<sup>n</sup> 即可以用它的递归定义：    

```
f(n) = f(n-1) * a    // n > 0
     = a             // n = 0
```    

从顶至下地计算，也可以从底至上地把 a 自乘 n-1 次。     

**减常因子** 技术意味着在算法的每次迭代中，总是从实例的规模中减去一个相同的常数因子。在大多数
应用中，这样的常数因子等于2.    

@TODO    

继续看指数问题，规模减半的实例计算就是 a<sup>n/2</sup> 的值，它们之间有着明显的关系：
a<sup>n</sup> = (a<sup>n/2</sup>)<sup>2</sup>。但因为我们只考虑整数指数的问题实例，
前面这个办法只对偶数 n 有效。如果 n 是奇数，我们必须使用偶指数规则计算 a<sup>n-1</sup>,
然后把结果乘以 a。    

这样该算法的复杂度为 θ(logn)。    

感觉减治法就是把方案一致减下去，然后再简单地把结果合起来。分治法的话，好像在合并的时候要进行
很多复杂的操作。   



