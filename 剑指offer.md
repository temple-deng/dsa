# 第 2 章 基础知识

## 2.3 数据结构

### 2.3.1 数组

#### 二维数组的查找

题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的
顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。    

可以选取右上角或左下角的数开始，以右上角为例，如果当前数大于要查找的数，则可以将当前列
整个弃掉，因为其一列的值只能更大，如果当前数小于要查找的数，则一行被丢弃掉。    

```go
func find(matrix [][]int, key int) bool {
	rows := len(matrix)
	if rows == 0 {
		return false
	}

	columns := len(matrix[0])
	if columns == 0 {
		return false
	}

	row := 0
	column := columns - 1
	for ; row < rows && column >= 0; {
		if matrix[row][column] == key {
			return true
		} else if matrix[row][column] > key {
			column--
		} else {
			row++
		}
	}

	return false
}
```   

### 2.3.5 栈和队列

用两个栈实现一个队列。    

假设两个栈分别为 stack1, stack2。    

入队时，我们将元素推入 stack1，当出队时，检查 stack2 是否为空，如果为空，将 stack1 元素
全部出栈并依次入栈 stack2，然后将 stack2 栈顶元素出栈，如果 stack2 不为空，那直接将栈顶
元素出栈即可。   

用两个队列实现一个栈。    

假设两个队列分别为 queue1, queue2。    

首先把元素假如都入队 queue1, 在出栈时，先将前 n-1 个元素出队，并入队 queue2, 然后将剩下
的最后一个元素出队。     

## 2.4 算法和数据操作

### 2.4.1 查找和排序

#### 旋转数组的最小数字

和二分查找法一样,我们用两个指针分别指向数组的第一个元素和最后一个元素。按照题目中旋转的规则,
第一个元素应该是大于或者等于最后一个元素的(这其实不完全对,还有特例,后面再加以讨论)。这里的
特例是刚好旋转了一轮或者就是一个 0 旋转，导致一个没旋转的效果。这时候第一个元素就是最小的元素。    

接着我们可以找到数组中间的元素。如果该中间元素位于前面的递增子数组,那么它应该大于或者等于第
一个指针指向的元素。此时数组中最小的元素应该位于该中间元素的后面。我们可以把第一个指针指向
该中间元素,这样可以缩小寻找的范围。移动之后的第一个指针仍然位于前面的递增子数组之中。    

同样,如果中间元素位于后面的递增子数组,那么它应该小于或者等于第二个指针指向的元素。此时该数组
中最小的元素应该位于该中间元素的前面。我们可以把第二个指针指向该中间元素,这样也可以缩小寻找的
范围。移动之后的第二个指针仍然位于后面的递增子数组之中。   

不管是移动第一个指针还是第二个指针,查找范围都会缩小到原来的一半。接下来我们再用更新之后的两个
指针,重复做新一轮的查找。     

按照上述的思路, **第一个指针总是指向前面递增数组的元素,而第二个指针总是指向后面递增数组的元素**。
最终第一个指针将指向前面子数组的最后一个元素,而第二个指针会指向后面子数组的第一个元素。
也就是它们最终会指向两个相邻的元素,而第二个指针指向的刚好是最小的元素。这就是循环结束的条件。    


```go
func min(nums []int) int {
  n := len(nums)
  if n == 0 {
    return -1
  }

  index1 := 0
  index2 := n-1
  // 这里是支持了数组未旋转的情况，这时就无法进入下面的循环，而这时最小元素就是第一个元素
  indexMid := index1

  for ; nums[index1] >= nums[index2]; {
    if index2 - index1 == 1 {
      indexMid = index2
      break
    }
    indexMid = (index2 - index1) / 2 + index1
    if nums[index1] <= nums[indexMid] {
      index1 = indexMid
    } else if nums[indexMin] <= nums[index2] {
      index2 = indexMid
    }
  }
  return nums[indexMid]
}
```    

这个算法好像在一些边界条件上还有问题。    

### 2.4.3 位运算

#### 二进制中 1 的个数

先判断整数二进制表示中最右边一位是不是1。接着把输入的整数右移一位，此时原来处于从右边数
起的第二位被移到最右边了，再判断是不是1。这样每次移动一位，直到整个整数变成0为止。现在
的问题变成怎么判断一个整数的最右边是不是1了。这很简单，只要把整数和1做位与运算看结果是
不是0就知道了。1除了最右边的一位之外所有位都是0。如果一个整数与1做与运算的结果是1，表示
该整数最右边一位是1，否则是0。    

```c
int NumberOf1(int n) {
  int count = 0;
  while(n) {
    if ( n & 1) {
      count++;
    }
    n = n >> 1;
  }
  return count;
}
```    

面试官看了代码之后可能会问：把整数右移一位和把整数除以2在数学上是等价的，那上面的代码中
可以把右移运算换成除以2吗？答案是否定的。因为除法的效率比移位运算要低得多，在实际编程中应尽可
能地用移位运算符代替乘除法。    

面试官接下来可能要问的第二个问题就是：上面的函数如果输入一个负数，比如0x80000000，运行
的时候会发生什么情况？把负数0x80000000右移一位的时候，并不是简单地把最高位的1移到第二位变
成0x40000000，而是0xC0000000。这是因为移位前是个负数，仍然要保证移位后是个负数，因此移
位后的最高位会设为1。如果一直做右移运算，最终这个数字就会变成0xFFFFFFFF而陷入死循环。    

为了避免死循环，我们可以不右移输入的数字i。首先把i和1做与运算，判断i的最低位是不是为1。
接着把1左移一位得到2，再和i做与运算，就能判断i的次低位是不是1……这样反复左移，每次都能判断i的其
中一位是不是1。基于这种思路，我们可以把代码修改如下:   

```c
int NumberOf1(int n) {
  int count = 0;
  unsigned int flag = 1;
  while(flag) {
    if (n & flag) {
      count++;
    }
    flag = falg << 1;
  }
  return count;
}
```    

我们发现把一个整数减去1，都是把最右边的1变成0。如果它的右边还有0的话，所有的0都变成1，
而它左边所有位都保持不变。接下来我们把一个整数和它减去1的结果做位与运算，相当于把它最右
边的1变成0。还是以前面的1100为例，它减去1的结果是1011。我们再把1100和1011做位与运算，
得到的结果是1000。我们把1100最右边的1变成了0，结果刚好就是1000。     

我们把上面的分析总结起来就是：把一个整数减去1，再和原整数做与运算，会把该整数最右边一个
1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。基于这种思路，我们可
以写出新的代码：    

```c
int NumberOf1(int n) {
  int count = 0;
  while(n) {
    count++;
    n = n & (n-1);
  }
  return count;
}
```    

相关题目：   

+ 用一条语句判断一个整数是不是2的整数次方。一个整数如果是2的整数次方，那么它的二进制表
示中有且只有一位是1，而其他所有位都是0。根据前面的分析，把这个整数减去1之后再和它自己做与运算，
这个整数中唯一的1就会变成0。
+ 输入两个整数m和n，计算需要改变m的二进制表示中的多少位才能得到n。比如10的二进制表示为
1010，13的二进制表示为1101，需要改变1010中的3位才能得到1101。我们可以分为两步解决这个问题：
第一步求这两个数的异或，第二步统计异或结果中1的位数。    

# 第 3 章 高质量的代码

## 3.3 代码的完整性

#### 数值的整数次方

需要注意的点有指数为负数的情况。以及底为 0 的情况，0 的 0 次方是没有意义的，这时候具体
返回什么或者是抛出错误要咨询面试官。    

由于计算机表示小数（包括float和double型小数）都有误差，我们不能直接用等号（==）
判断两个小数是否相等。如果两个小数的差的绝对值很小，比如小于0.0000001，就可以认为它
们相等。     

但是好像在 Go 中是可以直接相比的。    

## 3.4 代码的鲁棒性

+ 求链表的中间节点。如果链表中结点总数为奇数，返回中间结点；如果结点总数是偶数，返回中间
两个结点的任意一个。为了解决这个问题，我们也可以定义两个指针，同时从链表的头结点出发，一个指
针一次走一步，另一个指针一次走两步。当走得快的指针走到链表的末尾时，走得慢的指针正好在
链表的中间。    
+ 判断一个单向链表是否形成了环形结构。和前面的问题一样，定义两个指针，同时从链表的头结点
出发，一个指针一次走一步，另一个指针一次走两步。如果走得快的指针追上了走得慢的指针，那么链表
就是环形链表；如果走得快的指针走到了链表的末尾（m_pNext指向NULL）都没有追上第一个指针，
那么链表就不是环形链表。    

# 第 4 章 解决面试题的思路

## 4.3 举例让抽象问题具体化

#### 包含 min 函数的栈

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用
min、push及pop的时间复杂度都是O（1）。    

根据情况来看，需要一个辅助栈，这个栈严格来说是一个排序栈，每次入栈一个元素时，我们的辅助栈也要
入栈一个元素，这个元素是新元素和当前辅助栈顶元素直接的较小值。    

#### 二叉树的后序遍历

题目:输入一个整数数组,判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则
返回false。假设输入的数组的任意两个数字都互不相同。    

在后序遍历得到的序列中,最后一个数字是树的根结点的值。数组中前面的数字可以分为两部分:第一部分
是左子树结点的值,它们都比根结点的值小;第二部分是右子树结点的值,它们都比根结点的值大。    

# 第 5 章 优化时间和空间效率

#### 两个链表的第一个公共节点

由于是单向链表的结点,每个结点只有一个m_pNext,因此从第一个公共结点开始,之后它们所有结点都是
重合的,不可能再出现分叉。    

过分析我们发现,如果两个链表有公共结点,那么公共结点出现在两个链表的尾部。如果我们从两个链表的
尾部开始往前比较,最后一个相同的结点就是我们要找的结点。可问题是在单向链表中,我们只能从头结点
开始按顺序遍历,最后才能到达尾结点。最后到达的尾结点却要最先被比较,这听起来是不是像“后进先出”?
于是我们就能想到用栈的特点来解决这个问题:分别把两个链表的结点放入两个栈里,这样两个链表的尾结点
就位于两个栈的栈顶,接下来比较两个栈顶的结点是否相同。如果相同,则把栈顶弹出接着比较下一个栈顶,
直到找到最后一个相同的结点。    

之所以需要用到栈,是因为我们想同时遍历到达两个栈的尾结点。当两个链表的长度不相同时,如果我们
从头开始遍历到达尾结点的时间就不一致。其实解决这个问题还有一个更简单的办法:首先遍历两个链
表得到它们的长度,就能知道哪个链表比较长,以及长的链表比短的链表多几个结点。在第二次遍历的时候,
在较长的链表上先走若干步,接着再同时在两个链表上遍历,找到的第一个相同的结点就是它们的第一
个公共结点。    

# 第 6 章 面试中的各种能力

#### 数组中只出现一次的数字

题目:一个整型数组里除了两个数字之外,其他的数字都出现了两次。请写程序找出这两个只出现一次的
数字。要求时间复杂度是O(n),空间复杂度是O(1)。    

这两个题目都在强调一个(或两个)数字只出现一次,其他的出现两次。这有什么意义呢?我们想到异或
运算的一个性质:任何一个数字异或它自己都等于0。也就是说,如果我们从头到尾依次异或数组中的
每一个数字,那么最终的结果刚好是那个只出现一次的数字,因为那些成对出现两次的数字全部在异或中抵消了。    

想明白怎么解决这个简单问题之后,我们再回到原始的问题,看看能不能运用相同的思路。我们试着把原数组
分成两个子数组,使得每个子数组包含一个只出现一次的数字,而其他数字都成对出现两次。如果能够这样
拆分成两个数组,我们就可以按照前面的办法分别找出两个只出现一次的数字了。   

我们还是从头到尾依次异或数组中的每一个数字,那么最终得到的结果就是两个只出现一次的数字的异或结果。
因为其他数字都出现了两次,在异或中全部抵消了。由于这两个数字肯定不一样,那么异或的结果肯定不为0,
也就是说在这个结果数字的二进制表示中至少就有一位为1。我们在结果数字中找到第一个为1的位的位置,
记为第n位。现在我们以第n位是不是1为标准把原数组中的数字分成两个子数组,第一个子数组中每个数字的
第n位都是1,而第二个子数组中每个数字的第n位都是0。由于我们分组的标准是数字中的某一位是1还是0,
那么出现了两次的数字肯定被分配到同一个子数组。因为两个相同的数字的任意一位都是相同的,我们不可能
把两个相同的数字分配到两个子数组中去,于是我们已经把原数组分成了两个子数组,每个子数组都包含一个只出
现一次的数字,而其他数字都出现了两次。我们已经知道如何在数组中找出唯一一个只出现一次数字,因此
到此为止所有的问题都已经解决了。     

举个例子,假设输入数组{2,4,3,6,3,2,5,5}。当我们依次对数组中的每一个数字做异或运算之后,得到
的结果用二进制表示是0010。异或得到结果中的倒数第二位是1,于是我们根据数字的倒数第二位是不是1分
为两个数组。第一个子数组{2,3,6,3,2}中所有数字的倒数第二位都是1,而第二个子数组{4,5,5}中所有
数字的倒数第二位都是0。接下来只要分别对这两个子数组求异或,就能找出第一个子数组中只出现一次的数字
是6,而第二个子数组中只出现一次的数字是4。    