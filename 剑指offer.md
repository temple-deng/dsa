# 第 2 章 基础知识

## 2.3 数据结构

### 2.3.1 数组

#### 二维数组的查找

题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的
顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。    

可以选取右上角或左下角的数开始，以右上角为例，如果当前数大于要查找的数，则可以将当前列
整个弃掉，因为其一列的值只能更大，如果当前数小于要查找的数，则一行被丢弃掉。    

```go
func find(matrix [][]int, key int) bool {
	rows := len(matrix)
	if rows == 0 {
		return false
	}

	columns := len(matrix[0])
	if columns == 0 {
		return false
	}

	row := 0
	column := columns - 1
	for ; row < rows && column >= 0; {
		if matrix[row][column] == key {
			return true
		} else if matrix[row][column] > key {
			column--
		} else {
			row++
		}
	}

	return false
}
```   

### 2.3.5 栈和队列

用两个栈实现一个队列。    

假设两个栈分别为 stack1, stack2。    

入队时，我们将元素推入 stack1，当出队时，检查 stack2 是否为空，如果为空，将 stack1 元素
全部出栈并依次入栈 stack2，然后将 stack2 栈顶元素出栈，如果 stack2 不为空，那直接将栈顶
元素出栈即可。   

用两个队列实现一个栈。    

假设两个队列分别为 queue1, queue2。    

首先把元素假如都入队 queue1, 在出栈时，先将前 n-1 个元素出队，并入队 queue2, 然后将剩下
的最后一个元素出队。     

## 2.4 算法和数据操作

### 2.4.3 位运算

#### 二进制中 1 的个数

先判断整数二进制表示中最右边一位是不是1。接着把输入的整数右移一位，此时原来处于从右边数
起的第二位被移到最右边了，再判断是不是1。这样每次移动一位，直到整个整数变成0为止。现在
的问题变成怎么判断一个整数的最右边是不是1了。这很简单，只要把整数和1做位与运算看结果是
不是0就知道了。1除了最右边的一位之外所有位都是0。如果一个整数与1做与运算的结果是1，表示
该整数最右边一位是1，否则是0。    

```c
int NumberOf1(int n) {
  int count = 0;
  while(n) {
    if ( n & 1) {
      count++;
    }
    n = n >> 1;
  }
  return count;
}
```    

面试官看了代码之后可能会问：把整数右移一位和把整数除以2在数学上是等价的，那上面的代码中
可以把右移运算换成除以2吗？答案是否定的。因为除法的效率比移位运算要低得多，在实际编程中应尽可
能地用移位运算符代替乘除法。    

面试官接下来可能要问的第二个问题就是：上面的函数如果输入一个负数，比如0x80000000，运行
的时候会发生什么情况？把负数0x80000000右移一位的时候，并不是简单地把最高位的1移到第二位变
成0x40000000，而是0xC0000000。这是因为移位前是个负数，仍然要保证移位后是个负数，因此移
位后的最高位会设为1。如果一直做右移运算，最终这个数字就会变成0xFFFFFFFF而陷入死循环。    

为了避免死循环，我们可以不右移输入的数字i。首先把i和1做与运算，判断i的最低位是不是为1。
接着把1左移一位得到2，再和i做与运算，就能判断i的次低位是不是1……这样反复左移，每次都能判断i的其
中一位是不是1。基于这种思路，我们可以把代码修改如下:   

```c
int NumberOf1(int n) {
  int count = 0;
  unsigned int flag = 1;
  while(flag) {
    if (n & flag) {
      count++;
    }
    flag = falg << 1;
  }
  return count;
}
```    

我们发现把一个整数减去1，都是把最右边的1变成0。如果它的右边还有0的话，所有的0都变成1，
而它左边所有位都保持不变。接下来我们把一个整数和它减去1的结果做位与运算，相当于把它最右
边的1变成0。还是以前面的1100为例，它减去1的结果是1011。我们再把1100和1011做位与运算，
得到的结果是1000。我们把1100最右边的1变成了0，结果刚好就是1000。     

我们把上面的分析总结起来就是：把一个整数减去1，再和原整数做与运算，会把该整数最右边一个
1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。基于这种思路，我们可
以写出新的代码：    

```c
int NumberOf1(int n) {
  int count = 0;
  while(n) {
    count++;
    n = n & (n-1);
  }
  return count;
}
```    

相关题目：   

+ 用一条语句判断一个整数是不是2的整数次方。一个整数如果是2的整数次方，那么它的二进制表
示中有且只有一位是1，而其他所有位都是0。根据前面的分析，把这个整数减去1之后再和它自己做与运算，
这个整数中唯一的1就会变成0。
+ 输入两个整数m和n，计算需要改变m的二进制表示中的多少位才能得到n。比如10的二进制表示为
1010，13的二进制表示为1101，需要改变1010中的3位才能得到1101。我们可以分为两步解决这个问题：
第一步求这两个数的异或，第二步统计异或结果中1的位数。    

# 第 3 章 高质量的代码

## 3.3 代码的完整性

#### 数值的整数次方

需要注意的点有指数为负数的情况。以及底为 0 的情况，0 的 0 次方是没有意义的，这时候具体
返回什么或者是抛出错误要咨询面试官。    

由于计算机表示小数（包括float和double型小数）都有误差，我们不能直接用等号（==）
判断两个小数是否相等。如果两个小数的差的绝对值很小，比如小于0.0000001，就可以认为它
们相等。     

## 3.4 代码的鲁棒性

+ 求链表的中间节点。如果链表中结点总数为奇数，返回中间结点；如果结点总数是偶数，返回中间
两个结点的任意一个。为了解决这个问题，我们也可以定义两个指针，同时从链表的头结点出发，一个指
针一次走一步，另一个指针一次走两步。当走得快的指针走到链表的末尾时，走得慢的指针正好在
链表的中间。    
+ 判断一个单向链表是否形成了环形结构。和前面的问题一样，定义两个指针，同时从链表的头结点
出发，一个指针一次走一步，另一个指针一次走两步。如果走得快的指针追上了走得慢的指针，那么链表
就是环形链表；如果走得快的指针走到了链表的末尾（m_pNext指向NULL）都没有追上第一个指针，
那么链表就不是环形链表。    

# 第 4 章 解决面试题的思路

## 4.3 举例让抽象问题具体化

#### 包含 min 函数的栈

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用
min、push及pop的时间复杂度都是O（1）。    



