# 编程之美

# 第 1 章 游戏之乐

## 1.1 让CPU占用率曲线听你指挥

写一个程序,让用户来决定Windows任务管理器(Task Manager)的CPU占用率。程序越精简越好,
计算机语言不限。例如,可以实现下面三种情况:   

1. CPU的占用率固定在50%,为一条直线;
2. CPU的占用率为一条直线,但是具体占用率由命令行参数决定(参数范围1~100);
3. CPU的占用率状态是一个正弦曲线    

**解法一：简单的解法**    

要操纵 CPU 的使用率曲线,就需要使CPU在一段时间内(根据Task Manager的采样率)跑 busy 和
idle 两个不同的循环(loop),从而通过不同的时间比例,来调节CPU使用率。   

Busy loop 可以通过执行空循环来实现,idle 可以通过 Sleep() 来实现。    

问题的关键在于如何控制两个 loop 的时间。    

对于一个空循环 `for( i = 0; i < n; i++)` 该如何估计这个最合适的 n 值。我们都知道 CPU
执行的是机器指令，而最接近于机器指令的语言是汇编，所以我们可以先把这个空循环简单地写成如下汇编
代码后再进行分析：    

```asm
loop:
mov dx i       ; 将 i 置入 dx 寄存器
inc dx         ; 将 dx 寄存器加 1
mov i dx       ; 将 dx 中的值赋回 i
cmp i n        ; 比较 i 和 n
jl loop        ; i 小于 n 时则重复循环
```    

假设这段代码要运行的CPU是P4 2.4Ghz(2.4*10的9次方个时钟周期每秒)。现代CPU每个时钟周期
可以执行两条以上的代码,那么我们就取平均值两条,于是让(2400000000 * 2) / 5 = 960000000(循环/秒),
也就是说 CPU 1 秒钟可以运行这个空循环 960000000 次。不过我们还是不能简单地将 n = 60000000,
然后 Sleep(1000) 了事。如果我们让 CPU 工作1秒钟,然后休息1秒钟,波形很有可能就是锯齿状的
——先达到一个峰值(>50%),然后跌到一个很低的占用率。    

我们尝试着降低两个数量级,令 n = 9600000,而睡眠时间相应改为 10 毫秒(Sleep(10))。用10
毫秒是因为它不大也不小,比较接近Windows的调度时间片。如果选得太小(比如1毫秒),则会造成线程频
繁地被唤醒和挂起,无形中又增加了内核时间的不确定性影响。最后我们可以得到如下代码:    

```c
int main() {
  for(; ;) {
    for (int i = 0; i < 9600000; i++) {

    }
    Sleep(10);
  }
  return 0;
}
```    

该方法的缺点也很明显:不能适应机器差异性。一旦换了一个 CPU,我们又得重新估算n值。    

**解法二：使用 GetTickCount() 和 Sleep()**    

我们知道 `GetTickCount()` 可以得到“系统启动到现在”所经历时间的毫秒值,最多能够统计到49.7天。
我们可以利用 `GetTickCount()` 来判断 busy loop要循环多久:   

```c
int busyTime = 10;
int idleTime = busyTime;

Int64 startTime = 0;
while(true) {
  startTime = GetTickCount();

  while((GetTickCount() - startTime) <= busyTime)
    ;

  Sleep(idleTime);
}
```     

## 1.2 中国象棋将帅问题

请写一个程序，输出将和帅的所有合法位置，要求在代码中只能使用一个变量。    

稍微思考一下，可以知道这个程序的大体框架是：   

```
遍历 A 的位置
  遍历 B 的位置
    判断 A，B 的位置组合是否满足要求
    如果满足，则输出
```    

需要存储的是A、B的位置信息,并且每次循环都要更新。为了能够进行判断,首先需要创建一个逻辑的
坐标系统,以便检测 A 何时会面对 B。这里我们想到的方法是用 1~9 的数字,按照行优先的顺序
来表示每个格点的位置。这样,只需要用模余运算就可以得到当前的列号,从而判断A、B是否互斥。    

一个8位的 byte 类型能够表达 2 = 256个值,所以用它来表示A、B的位置信息绰绰有余,因此可以把
这个字节的变量(设为b)分成两部分。用前面的4bit表示A的位置,用后面的4bit表示B的位置,那么4个bit
可以表示16个数,这已经足够了。    

问题在于:如何使用bit级的运算将数据从这一byte变量的左边和右边分别存入和读出。     

+ 将 byte b(10100101) 的右边 4bit 设为 n(0011):    

首先清除 b 右边的 bits，同时保持左边的 bits:    

```
    1 1 1 1 0 0 0 0 (LMASK)
  & 1 0 1 0 0 1 0 1 (b)
   -----------------
    1 0 1 0 0 0 0 0
```    

然后将上一步得到的结果与 n 做或运算：    

```
    1 0 1 0 0 0 0 0 (LMASK & b)
  ^ 0 0 0 0 0 0 1 1 (n)
  --------------------
    1 0 1 0 0 0 1 1
```    

+ 将 byte b(10100101) 左边的 4bit 设为 n(0011):    

和上边的就差不多了，先和 RMASK &，把左边的 bits 清空，然后把 n 左移 4 位再或。    

+ 得到 byte 数据的右边 bits：和 RMASK & 就够了
+ 得到 byte 数据左边的 bits：先和 LMASK &，再把结果右移 4 位