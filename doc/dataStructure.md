# 数据结构

## 为什么要学习数据结构   

- 线性结构
- 树结构
- 图结构    


- 数组
- 栈
- 队列
- 链表
- 二分搜索树
- 堆
- 线段树
- Trie
- 并查集
- AVL
- 红黑树
- 哈希表       

## 数组    

- addLast(e): O(1)，均摊 O(1)
- addFirst(e): O(n)
- add(index, e): O(n)
- removeLast(e): O(1)
- removeFirst(e): O(n)，均摊 O(1)
- remove(index): O(n)
- set(index, e): O(1)
- get(index): O(1)
- contains(e): O(n)
- find(e): O(n)    

## 栈和队列   

栈：   

- LIFO
- `push(E): void`
- `pop(): E`
- `peek(): E`
- `getSize(): number`
- `isEmpty(): boolean`   

队列：
- FIFO   

```ts
export interface Queue<T> {
    enqueue(e: T): void;
    dequeue(): T;
    getFront(): T;
    getSize(): number;
    isEmpty(): boolean;
}
```    

## 树    

二分搜索树。Binary Search Tree。    

- 元素具有可比较性
- 前、中、后 三序遍历
- 层序遍历   

## 堆    

- 二叉堆是一颗完全二叉树
- 最大堆：堆中某个节点的值总是不大于其父节点的值
- 用数组存储二叉堆     
- 平衡二叉树 
- parent(i) = Math.floor(i / 2)
- leftChild(i) = i * 2
- rightChild(i) = i * 2 + 1
- 如果以 0 为起点 parent(i) = Math.floor((i - 1) / 2);
- leftChild(i) = i * 2 + 1
- rightChild(i) = i * 2 + 2    

## 线段树    

- 更新
- 查询
- 不考虑添加或删除元素
- 集合是固定的
- 平衡二叉树
- n 个元素，4n 个节点


## 并查集

- union(p, q)
- isConnected(p, q)
- 集合 id
- quick find
- quick union
- size 优化
- rank 优化

## AVL 树

- 左子树和右子树高度差不超过1
- 平衡因子 - 高度差
- 插入的元素在不平衡元素的左侧的左侧     
- 右旋转

```
LL
                Y                           X
              /  \                        /   \
            X     T4                    Z      Y
          /   \         ->            /  \     /  \
         Z    T3                    T1   T2   T3  T4
        /  \
       T1  T2

X.right = Y
Y.left = T3
```    

- 插入的元素在不平衡元素的右侧的右侧
- 左旋转    

```
RR
            Y                              X
          /   \                          /    \
        T4     X           ->          Y       Z
             /   \                   /   \     /   \
            T3   Z                 T4    T3   T1   T2
               /    \
             T1     T2
```    

## 红黑树   

- 根节点是黑色
- 每个叶子节点（最后的空节点）都是黑色
- 如果一个节点是红色的，那么两个孩子一定是黑色的
- 从任意一个节点到叶子节点,经过的黑色节点是一样的
- 2-3 树是一颗绝对平衡的树
- 绝对平衡 - 从根节点到任意一颗叶子节点经过节点数量是相同的
- 2-3 树添加节点绝对不会添加到一个空的位置    


```
                       红边
     a              b ----  c
   /   \          /  \       \
```

向 2-3 树中添加节点：  

- 2节点中添加节点，组成3节点 - 树是平衡的，什么也不用做，换成红黑树就是，向一个黑节点上并一个红节点，然后
分情况讨论
    + 如果红节点现在放在左边，那什么也不用做
    + 如果现在红节点放在右边，那么需要左旋一下，并且红节点转黑，黑节点转红
- 而向 3 节点添加节点，组成 4 节点，这时候就要进行节点的拆分了，向上融合节点要为红色
    + 假如节点放到了红节点的左侧，这时候红节点向上合并，右旋，整体颜色反转
    + 假如节点放到了红节点右侧，先子树左旋，然后大树右旋？，颜色呢
    + 假如放到了黑节点右侧，换 2-3树里面，把中间节点上浮就行了，也就是把中间黑节点合上去，这时候
        需要把颜色都反转了，两个红变黑，表示两个成为了2节点，黑节点暂时变红，表示暂时向上融合到左边了


- 保持根节点黑色

## 玩转数据结构   

- 动态数组
- 栈和队列
- 链表
- 集合和映射
- 二叉树
- 堆，优先队列
- 线段树
- trie 树
- 并查集
- avl 树
- 红黑树
- 哈希表

## 算法与数据结构

- 排序
- 堆和堆排序
- bst
- 并查集
- 图论


## 算法面试    

