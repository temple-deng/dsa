# 第 1 章 绪论

## 1.1 复杂度度量

### 1.1.1 时间复杂度

随着输入规模的增大，算法的执行时间将如何增长？执行时间的这一变化趋势可表示为输入规模的
一个函数，称作该算法的时间复杂度。具体地，特定算法处理规模为 n 的问题所需时间可记作 T(n)。     

根据规模并不能唯一确定具体的输入，规模相同的输入通常有多个，而算法对其进行处理所需时间也
不尽相同。以排序问题为例，由 n 个元素组成的输入序列有 n! 的种，有时所有元素都需交换，
有时却无需任何交换。故严格来说，以上定义的 T(n) 并不明确。为此需要再做一次简化。即从、保守估计的角度出发，在规模为 n 的所有输入中选择执行时间最长者作为 T(n)，并以 T(n) 度量
该算法的时间复杂度。    

### 1.1.2 渐进复杂度

针对足够大的输入规模 n，算法执行时间 T(n) 的渐进上界，应如何度量和评价呢？    

**大 O 记号**     

同样地出于保守的估计，我们首先关注T(n)的渐进上界。为此可引入所谓“大O记号”。具体地，若存
在正的常数 c 和函数 f(n)，使得对任何 n >> 2 都有：    

`T(n) <= c * f(n)`     

则可认为在n足够大之后，f(n)给出了T(n)增长速度的一个渐进上界。此时，记之为：   

`T(n) = O(f(n))`     

由这一定义，可导出大 O 记号的以下性质：   

1. 对于任一常数 c > 0，有 `O(f(n)) = O(c * f(n))`
2. 对于任意常数 a > b > 0, 有 O(n<sup>a</sup> + n<sup>b</sup>) = O(n<sup>a</sup>)    

前一性质意味着，在大 O 记号的意义下，函数各项正的常系数可以忽略并等同于 1。后一性质意味
着，多项式中的低次项均可忽略，只需保留最高次项。   

**基本操作**    

一种自然且可行的解决办法是，将时间复杂度理解为算法中各条指令的执行时间之和，在大多数实际
的计算环境中，每一次这类基本操作都可在常数时间内完成。    

如此，不妨将 T(n) 定义为算法所执行基本操作的总次数，也就是说，T(n) 决定于组成算法的所有
语句各自的执行次数，以及其中所含基本操作的数目。   

**大 Ω 记号**    

为了对算法的复杂度最好情况作出估计，需要借助另一个记号。如果存在正的常数 c 和函数 g(n)，
使得对于任何 n >> 2 都有：    

`T(n) >= c * g(n)`    

就可以认为，在 n 足够大之后， g(n) 给出了 T(n) 的一个渐进下界，此时，我们记之为：    

`T(n) = Ω(g(n))`     

大 Ω 记号是对算法执行效率的乐观估计——对于规模为 n 的任意输入，算法的运行时间都不低于
Ω(g(n))。    

**大 θ 记号**    

借助大 O 记号，大 Ω 记号，可以对算法的时间复杂度作为定量的界定，亦即，从渐进的趋势来看，
T(n) 介于 Ω(g(n)) 和 O(f(n)) 之间。若恰好出现 g(n) = f(n)的情况，则可以使用另一记号
来表示。    

如果存在正的常数 c1 < c2 和函数 h(n)，使得对于任何 n >> 2 都有：    

`c1 * h(n) <=  T(n) <= c2 * h(n)`    

就可以认为在 n 足够大之后，h(n) 给出了 T(n) 的一个确界。此时，我们记之为：   

`T(n) = θ(h(n))`    

数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。    

## 1.2 逻辑结构与物理结构

按照视点的不同，我们把数据结构分为逻辑结构和物理结构。

### 1.2.1 逻辑结构

逻辑结构：是指数据对象中数据元素之间的相互关系。逻辑结构分为以下四种：    

1. 集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。
2. 线性结构：线性结构中的数据元素之间是一对一的关系。
3. 树形结构：树形结构中的数据元素之间存在一种一对多的层次关系。
4. 图形结构：图形结构的数据元素是多对多的关系。       

### 1.2.2 物理结构

物理结构：是指数据的逻辑结构在计算机中的存储形式。    

数据元素的存储结构形式有两种：顺序存储和链式存储。    

1. 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。
2. 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。      
